<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liangsw</title>
  
  <subtitle>liangsw</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liangsw.me/"/>
  <updated>2019-05-07T11:41:13.361Z</updated>
  <id>https://liangsw.me/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>加载相关数据</title>
    <link href="https://liangsw.me/2019/05/07/Loadingrelateddata/"/>
    <id>https://liangsw.me/2019/05/07/Loadingrelateddata/</id>
    <published>2019-05-07T07:33:00.000Z</published>
    <updated>2019-05-07T11:41:13.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h1 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a>第一部分目录<a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">导航</a></h1><h1 id="加载相关数据"><a href="#加载相关数据" class="headerlink" title="加载相关数据"></a>加载相关数据</h1><p>之前我向你展示了Book实体类,它有其他三个实体的导航属性: PriceOffer,Review和BookAuthor. 下面介绍如何使用代码访问这些数据. 你有以下方式加载数据: 贪婪加载,显式加载,选择加载和懒加载(在EF Core 2.1中)</p><p>有一点很重要,EF Core默认不会加载实体类的任何关系(导航属性),如果加载了Book类,在默认情况下Book实体的每个导航属性都为null</p><p>默认不加载任何关系的行为是正确的,这意味着EF Core最小化了数据库访问. 如果你想加载一个关系则添加需要代码告诉EF Core. 下面介绍三种方法,以及它们的优缺点</p><h2 id="贪婪加载-加载与主实体类的关系"><a href="#贪婪加载-加载与主实体类的关系" class="headerlink" title="贪婪加载: 加载与主实体类的关系"></a>贪婪加载: 加载与主实体类的关系</h2><p>加载相关数据的第一种方法是贪婪加载. 贪婪加载需要告诉EF Core在加载主实体数据的查询中加载导航属性. 使用两个方法Include和ThenInClude指定预先加载. 下个清单展示了Book实体类实例查询Books表的第一行数据以及贪婪加载单个关系Reviews</p><p><img src="https://img2018.cnblogs.com/blog/832799/201905/832799-20190507175620243-2058765510.png" referrerpolicy="no-referrer"></p><ul><li>EF6 EF Core的贪婪加载与EF 6.x的方法类似, 但EF Core改进了语法和SQL实现. EF 6.x没有ThenInclude方法, 并且EF 6.x的sql实现是尝试在一个查询中加载所有数据和集合,这样的SQL查询很可能是低效的. EF Core在一个单独的查询中加载集合,你可以在前面的SQL部分看到这一点</li></ul><p>下面我们看一个更复杂的例子,下面的清单展示了查询第一本书并且贪婪加载它所有的关系.</p><p><img src="https://img2018.cnblogs.com/blog/832799/201905/832799-20190507175752623-826759264.png" referrerpolicy="no-referrer"></p><p>之前展示了使用贪婪加载方法Include获取AuthorsLink关系(一级关系),直接由加载的实体类引用的关系. Include后面使用ThenInclude加载二级关系,本例中是BookAuthor的Author表. 这种方式(Include后面使用ThenInclude)是访问深层次关系的标准方法,你可以使用更多的ThenInclude深入更深的关系</p><p>如果数据不存在,比如Book类的Promotion属性指向的可选PriceOffer类,Include不会失败,它只是加载不到任何东西,如果是集合会返回一个空集合. ThenInclude也是这样. 如果前面的Include或Theninclude为空,后面的ThenInclude会被忽略</p><p>贪婪加载的缺点是会加载所有的数据,有时你不需要某些部分数据,例如图书列表不需要书籍描述,而图书描述一般会很长.</p><p>注: 在EF Core2.0中,如果你在查询中使用了不必要的Include方法,则会有一个警告,比如 <code>context.Books.Include(b =&gt; b.Promotion).Where( b =&gt; b.Promotion.NewPrice &gt; 10).Select(b =&gt; b.BookId)</code> 代码中使用了include,但它是不必要的,因为查询只返回了BookId. EF Core团队为此情况添加了警告,因为没有必要使用Inlcude方法.</p><h2 id="显式加载-在加载了实体类之后加载关系"><a href="#显式加载-在加载了实体类之后加载关系" class="headerlink" title="显式加载: 在加载了实体类之后加载关系"></a>显式加载: 在加载了实体类之后加载关系</h2><p>第二个方法是显式加载,加载了主实体类之后,使用显式加载其他所需的关系. 下面的代码首先加载了书籍,然后使用显式加载命令读取所有关系</p><p><img src="https://img2018.cnblogs.com/blog/832799/201905/832799-20190507193212640-2005340218.png" referrerpolicy="no-referrer"></p><p>显式加载有一个额外的命令,在加载数据的同时并且可用查询. 下面的代码展示了使用显式加载方法Query命令查询评论数量并加载每个评论的所有星级评分. 你可以在Query方法后使用LINQ命令,例如Where,Orderby等</p><p><img src="https://img2018.cnblogs.com/blog/832799/201905/832799-20190507193244076-258593752.png" referrerpolicy="no-referrer"></p><p>显式加载的优点是不会立即加载实体的关系. 这对于在某些情况下需要相关数据,显式加载会很有用. 你还会发现在复杂业务逻辑中显式加载也很有用</p><p>显式加载的缺点是会产生更多的数据库往返,这可能是低效的. 如果你事先知道所需的数据,那么贪婪加载通常会更好,因为加载关系所需的数据库往返次数更少</p><h2 id="选择加载-加载实体类的特定属性和关系"><a href="#选择加载-加载实体类的特定属性和关系" class="headerlink" title="选择加载: 加载实体类的特定属性和关系"></a>选择加载: 加载实体类的特定属性和关系</h2><p>第三种方法是使用LINQ的Select方法明确的选择需要的数据,我称之为选择加载. 下面展示了使用Select方法从Book类中选择属性,在查询中执行特定的代码获取书的评论数量</p><p><img src="https://img2018.cnblogs.com/blog/832799/201905/832799-20190507193306630-1204406274.png" referrerpolicy="no-referrer"></p><p>Select查询方法的优点是只加载你需要的数据,在你不需要所有的数据时,这会很有用. 上面的查询代码只需要一个Select SQL命令获取所有数据. 在数据库往返次数方面也很少. EF Core将查询的<code>p.Reviews.Count</code>转换为SQL命令,在数据库中完成计数. 如下面的SQL所示</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">TOP</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">[</span>Title<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">[</span>Price<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>        <span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>         <span class="token keyword">FROM</span> <span class="token punctuation">[</span>Review<span class="token punctuation">]</span> <span class="token keyword">AS</span> <span class="token punctuation">[</span>r0<span class="token punctuation">]</span>         <span class="token keyword">WHERE</span> <span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">[</span>BookId<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>r0<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token punctuation">[</span>BookId<span class="token punctuation">]</span> <span class="token punctuation">)</span>      <span class="token keyword">FROM</span> <span class="token punctuation">[</span>Books<span class="token punctuation">]</span> <span class="token keyword">AS</span> <span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>选择加载的缺点是需要为每个属性/计算编写代码. 这会很繁琐, 在10.3节中我介绍了一种自动化的方法</p><p>注: 在本章的后面,你会看到更复杂的选择加载案例,我们会使用这种类型的加载构建图书应用程序的图书列表查询</p><h2 id="EF-Core-2-1中的延迟加载"><a href="#EF-Core-2-1中的延迟加载" class="headerlink" title="EF Core 2.1中的延迟加载"></a>EF Core 2.1中的延迟加载</h2><p>在EF 6.x中将属性标记为virtual,在读取到该属性时会进行数据库访问. 延迟加载添加到了EF Core 2.1中</p><p>喜欢延迟加载的人说,延迟加载很容易使用,在读取属性时不需要应用程序数据库上下文. 延迟加载的缺点是对延迟加载的数据进行更多的数据库访问. 让查询变慢, 本章描述的三种方法在我看来完全可以消除延迟加载的存在意义,它们可以带来性能更高的数据库访问</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>理解EF Core数据库查询</title>
    <link href="https://liangsw.me/2019/04/26/Understandingdatabasequeries/"/>
    <id>https://liangsw.me/2019/04/26/Understandingdatabasequeries/</id>
    <published>2019-04-26T07:33:00.000Z</published>
    <updated>2019-04-26T07:53:46.295Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h1 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a>第一部分目录<a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">导航</a></h1><h1 id="理解EF-Core数据库查询"><a href="#理解EF-Core数据库查询" class="headerlink" title="理解EF Core数据库查询"></a>理解EF Core数据库查询</h1><p>现在我们去查看如何使用EF Core查询数据库了. 图2.7展示了一个示例查询,其中包含三个重要的部分</p><p><img src="https://img2018.cnblogs.com/blog/832799/201904/832799-20190426155244552-1571383791.png" referrerpolicy="no-referrer"></p><ul><li>注: 如果你熟悉EF 6.x或LINQ,可以跳过本节内容</li></ul><p>图2.7中展示了由几个方法组成的一行代码,它们是函数式编程的风格,这样的风格在逻辑上更加直观,更容易阅读. 下面描述代码的三个部分</p><h2 id="应用程序数据库上下文的属性访问"><a href="#应用程序数据库上下文的属性访问" class="headerlink" title="应用程序数据库上下文的属性访问"></a>应用程序数据库上下文的属性访问</h2><p>代码的第一部分通过EF Core连接到数据库, 引用数据库表的最常用的方法是通过数据库上下文的DbSet<t>属性</t></p><p>在本章都是使用数据库上下文的属性访问数据库表,在后面的章节会介绍到访问类或属性的其他方法,思想基本是一样的. 都需要通过EF Core连接到数据库开始</p><h2 id="一系列的LINQ-EF-Core-命令"><a href="#一系列的LINQ-EF-Core-命令" class="headerlink" title="一系列的LINQ/ EF Core 命令"></a>一系列的LINQ/ EF Core 命令</h2><p>这部分是一组LINQ或EF Core方法,由它们构造查询条件,根据业务LINQ查询语句可能会变得非常复杂. 本章从最简单的查询示例开始,在后面会介绍到构建复杂的查询语句</p><ul><li>注: 如果你不熟悉LINQ,那么接下来的内容会很难理解,建议你查看一些LINQ的资料,比如 <a href="https://docs.microsoft.com/zh-cn/previous-versions/dotnet/articles/bb308959(v=msdn.10)" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/previous-versions/dotnet/articles/bb308959(v=msdn.10)</a></li></ul><h2 id="执行查询命令"><a href="#执行查询命令" class="headerlink" title="执行查询命令"></a>执行查询命令</h2><p>代码的最后一部分很重要,在执行查询命令之前,LINQ被保存为一系统的命令,它并没有在数据上执行. EF Core将LINQ查询的每一个方法转换为正确的SQL在数据库中执行. 在EF Core中查询只有在查询方法调用时才会执行,例如<code>ToList()</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>创建应用程序的DbContext</title>
    <link href="https://liangsw.me/2019/04/25/Creatingtheapplication%E2%80%99sDbContext/"/>
    <id>https://liangsw.me/2019/04/25/Creatingtheapplication’sDbContext/</id>
    <published>2019-04-25T07:33:00.000Z</published>
    <updated>2019-04-25T10:55:29.686Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><p>第一部分目录<a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">导航</a></p><h1 id="创建应用程序的数据库上下文"><a href="#创建应用程序的数据库上下文" class="headerlink" title="创建应用程序的数据库上下文"></a>创建应用程序的数据库上下文</h1><p>访问数据库前我们需要以下操作:</p><ul><li>定义应用程序的数据库上下文,创建类并继承EF Core的DbContext类</li><li>访问数据库时,需要创建该类的实例</li></ul><p>本章后面所有的数据库查询都是这些步骤,下面我会详细的描述这些步骤</p><h2 id="定义应用程序的数据库上下文-EfCoreDbContext"><a href="#定义应用程序的数据库上下文-EfCoreDbContext" class="headerlink" title="定义应用程序的数据库上下文: EfCoreDbContext"></a>定义应用程序的数据库上下文: EfCoreDbContext</h2><p>使用EF Core的关键类就是应用程序的DbContext,该类继承EF Core的DbContext类. 添加各种属性代表数据库中的表. 它还可以覆盖基类方法使用EF Core的其他功能,比如配置数据库建模等. 图2.6展示了应用程序数据库上下文的概述并指出了重要的部分</p><p><img src="https://img2018.cnblogs.com/blog/832799/201904/832799-20190425185134334-707015186.png" referrerpolicy="no-referrer"></p><p>注: 上面没有介绍到配置数据库建模,在第六章与第七章中详细介绍了如何对数据库建模</p><h2 id="创建应用程序数据库上下文实例"><a href="#创建应用程序数据库上下文实例" class="headerlink" title="创建应用程序数据库上下文实例"></a>创建应用程序数据库上下文实例</h2><p>在第一章中我们在OnConfiguring方法中调用了<code>UseSqlServer</code>方法并硬编码了连接字符串,缺点很明显连接字符串是固定的,所以我们现在使用另一种方法. 我们希望使用不同的数据库用于开发和单元测试.</p><p>注: 第十五章介绍了对使用EF Core的应用程序进行单元测试</p><p>图2.2展示了创建应用程序数据库上下文时的选项,图中的代码是我在单元测试时使用的. 在第五章中介绍了在ASP.NET Core应用程序中使用EF Core,使用依赖注入的方式为应用程序提供数据库上下文的实例</p><p><img src="https://img2018.cnblogs.com/blog/832799/201904/832799-20190425185005984-724548352.png" referrerpolicy="no-referrer"></p><p>图的最后,使用了using语句包裹了创建数据库上下文实例的代码,因为DbContext实现了IDisposable接口. context变量就是我们需要的数据库上下文实例</p><h2 id="创建应用程序的数据库"><a href="#创建应用程序的数据库" class="headerlink" title="创建应用程序的数据库"></a>创建应用程序的数据库</h2><p>使用EF Core创建数据库有好几种方法,大多数都会选择使用EF Core的迁移. 使用应用程序的数据库上下文和实体类作为数据库结构的模型. <code>Add-Migration</code>命令进行数据库建模,然后使用模型构建命令创建对应的数据库</p><p>注: 如果你使用的代码是从Github仓库下载的,那么不需要执行我们下面要用的迁移命令</p><p>迁移的好处是可以将代码中所做的任何更改来更新数据库,如果更改实体类或数据库上下文配置,使用Add-Migration命令可以创建最新的迁移文件</p><p>使用迁移,我们需要在应用程序的启动项安装<code>Microsoft.EntityFramework.Tools</code>的NuGet包,它的功能是让你在包管理控制台(PPC)使用迁移命令</p><ul><li><code>Add-Migration MyMigrationName</code> 创建迁移命令,它会将所有更改(添加)的实体和等其他建模配置创建一个迁移文件, MyMigrationName是迁移的名称</li><li><code>Update-Database</code> 应用迁移命令,如果不存在数据库会数据一个数据库,如果已存在命令会检查数据库的迁移版本并更新到应用程序中的最新版本(也有命令可以更新到指定版本)</li></ul><p>注: 还可以使用EF Core的CLI运行这些命令 (参见<a href="https://docs.microsoft.com/zh-cn/ef/core/miscellaneous/cli/dotnet),第十一章列出了命令的列表" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/ef/core/miscellaneous/cli/dotnet),第十一章列出了命令的列表</a>. .Net Core2.1引入了全局工具可以直接运行命令</p><p>有另一种方法调用<code>Update-Database</code>命令,就是在应用程序的启动代码中调用<code>context.Database.Migrate</code>方法. 这种方法对托管的ASP.NET Core Web应用程序非常有用,第五章详细介绍了这种方法与其中的一些限制</p><p>注: 虽然EF Core的迁移功能很好用,但它并未涵盖所有类型的数据库结构更改. 对于某些项目据库据库不由EF Core定义和管理数据库,这意味着无法使用EF Core的迁移功能. 第十一章讨论了数据库迁移的选项以及它们的优缺点</p><h2 id="如果是分层应用程序怎么办"><a href="#如果是分层应用程序怎么办" class="headerlink" title="如果是分层应用程序怎么办"></a>如果是分层应用程序怎么办</h2><p>一般的应用程序都是分层的,主网站是一个项目,数据访问层又是一个项目. 这时<code>Add-Migration</code>命令就要复杂一点</p><p>在图书应用程序中,应用程序的数据库上下文在名为<code>DataLayer</code>的项目中,ASP.NET Core Web程序在名为<code>EfCoreInAction</code>的项目中(我会在后面讲到为什么这么分层). 要添加迁移命令如下</p><p><code>Add-Migration Chapter02 -Project DataLayer -StartupProject EfCoreInAction</code></p><p>图书应用程序的数据库上下文 <code>EfCoreContext</code> 类没有无参构造函数,<code>Add-Migration</code>命令会失败,要解决这个潜在的问题,我们需要创建一个<code>IDesignTimeDbContextFactory&lt;T&gt;</code>接口的实现类,因为<code>Add-Migration</code>命令会去查找这个接口的实现. 这个实现类创建应用程序的数据库上下文的正确配置实现,使<code>Add-Migration</code>命令可以正常工作. 这也是在图书应用程序中所做的. 参见 <a href="https://docs.microsoft.com/zh-cn/ef/core/miscellaneous/configuring-dbcontext#using-idesigntimedbcontextfactorytcontext" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/ef/core/miscellaneous/configuring-dbcontext#using-idesigntimedbcontextfactorytcontext</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>设置一个图书销售网站的场景</title>
    <link href="https://liangsw.me/2019/04/24/Settingthesceneourbook-sellingsite/"/>
    <id>https://liangsw.me/2019/04/24/Settingthesceneourbook-sellingsite/</id>
    <published>2019-04-24T06:02:00.000Z</published>
    <updated>2019-04-25T05:20:37.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h2 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a><a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">第一部分目录导航</a></h2><h1 id="假设场景-–-图书销售网站"><a href="#假设场景-–-图书销售网站" class="headerlink" title="假设场景 – 图书销售网站"></a>假设场景 – 图书销售网站</h1><p>在本章中你会构建一个图书销售网站示例,称之为图书应用程序. 这个示例应用程序帮助我们查看查询中的关系. 本节中介绍了图书应用程序所需的数据库与EF Core的实体类部分</p><ul><li>这里是图书应用程序的运行实例 <a href="http://efcoreinaction.com" target="_blank" rel="noopener">http://efcoreinaction.com</a></li></ul><h2 id="图书应用程序的关系型数据库"><a href="#图书应用程序的关系型数据库" class="headerlink" title="图书应用程序的关系型数据库"></a>图书应用程序的关系型数据库</h2><p>虽然我们可以将作者,书,评论等所有数据都放到一张表中,但在关系型数据库中这样设计是很糟糕的,关系型数据库的规范是分离重复的数据,例如作者</p><p>我们有多种方式在数据库设计图书数据的各种部分,在本例中的数据库具有EF Core的主要关系类型,分别是以下三种:</p><ul><li>一对一的关系: 书与优惠价格</li><li>一对多的关系: 书与评价</li><li>多对多的关系: 书与作者</li></ul><h3 id="一对一的关系-书与价格"><a href="#一对一的关系-书与价格" class="headerlink" title="一对一的关系: 书与价格"></a>一对一的关系: 书与价格</h3><p>一个书可以有促销价格,这通过PriceOffers表的一个可选行实现的,这是一个一对一的例子(从技术来讲,这是一个1-0或1的关系,不过EF Core的处理方式是一样的);参见图2.1</p><p><img src="https://img2018.cnblogs.com/blog/832799/201904/832799-20190424135316758-1525903325.png" referrerpolicy="no-referrer"></p><p>The PriceOffers table has a foreign key that links to the books table’s primary key</p><ul><li>PriceOffers表有一个连接到books表主键的外键</li></ul><p>EF Core uses its conventions to detect that this is a one-to-one relationship. It therefore adds a unique index to the foreign key to ensure that there can only be one per book</p><ul><li>EF Core使用它的约定来检测这是一个一对一的关系,因此它为外键添加了唯一索引,确保每本书只能有一个优惠价格</li></ul><p>计算图书的最终价格,需要通过外键找到与图书链接的优惠价格记录. 如果找到了记录,NewPrice会取代原书的价格,并将PromotionalText显示到屏幕上; 例如:</p><p>原价￥40现价￥9.9 温州印书场倒闭了,老板带着小姨子跑路了. 原价都是四十五十的,现价只要九块九</p><h3 id="一对多的关系-书的评论"><a href="#一对多的关系-书的评论" class="headerlink" title="一对多的关系: 书的评论"></a>一对多的关系: 书的评论</h3><p>顾客可以评价一本书;他们可以评星级,也可以留文字评论. 因为一本书可能没有一个评论或者有很多(无限)的评论,所以需要创建一张表保存这些数据. 在本例中它是Review表. Books表与Review表是一对多的关系, 如图2.2所示</p><p><img src="https://img2018.cnblogs.com/blog/832799/201904/832799-20190424135333019-4804873.png" referrerpolicy="no-referrer"></p><p>The Review table is linked to the Books table via the foreign key called BookId</p><ul><li>Review表通过BookId外键链接到Books表</li></ul><p>在显示图书介绍时,需要计算评论数量与平均星级评价. 这些通过一对多的关系去检索. 呈现在页面上是以下效果:</p><ul><li>平均分 4.5 共有1000用户评论</li></ul><h3 id="多对多的关系-图书与作者"><a href="#多对多的关系-图书与作者" class="headerlink" title="多对多的关系: 图书与作者"></a>多对多的关系: 图书与作者</h3><p>一书本可能由一个人编写也可能由多人编写, 一个人(作者)可以著作一本书或多本书. 这是一个典型的多对多关系,在数据库中Books表保存图书数据,Authors表保存作者. Books和Authors表之间的链接就是多对多关系. 它们之间需要一张中间表. 参见图2.3</p><p><img src="https://img2018.cnblogs.com/blog/832799/201904/832799-20190424135346171-619571042.png" referrerpolicy="no-referrer"></p><p>The BookAuthor table is the key to creating the many-to-many relationship and is known as a linking table</p><ul><li>BookAuthor表是多对多关系的核心,称为中间表</li></ul><p>This table uses the foreign keys as the primary keys. Because primary keys must be unique, this ensures that only one link can exist between a book and an author</p><ul><li>BookAuthor表使用外键做为主键,因为主键必须是唯一的, 所以确保了书和作者之间只能有一个链接</li></ul><p>多对多关系的页面展示如下</p><ul><li>删库到跑路 - 我的程序一生   赵日天,萧炎,林动 著</li></ul><p>EF6: 在EF6中定义多对多关系不需要链接类,EF6会自动创建隐藏的中间表.但是在EF Core中必须自己创建中间表</p><h2 id="本章中未涉及的其他关系类型"><a href="#本章中未涉及的其他关系类型" class="headerlink" title="本章中未涉及的其他关系类型"></a>本章中未涉及的其他关系类型</h2><p>使用EF Core你可以使用继承达到与之前一对一关系的类似结果,例如你可以将PriceOffer类继承自Book类. EF Core会使用第七章中介绍的table-per-hierarchy(TPH)实现. (子类和基类都需要包含在应用程序的DbContext中)</p><p>另一种是分层关系类型: 一组通过层次关系彼此关系的数据项目. 一个典型的例子是员工与经理,经理也是员工的一种. EF Core使用与一对五和一对多相同的方法来提供层次关系,在第七章详细讨论这类关系与如何配置</p><h2 id="最终数据库的样子"><a href="#最终数据库的样子" class="headerlink" title="最终数据库的样子"></a>最终数据库的样子</h2><p>图2.4展示了图书应用程序的数据库,在本章和第三章的示例中我们会使用到它. 图中包含了我们之前提到每张表与列的定义</p><p><img src="https://img2018.cnblogs.com/blog/832799/201904/832799-20190424135405058-882279717.png" referrerpolicy="no-referrer"></p><p>注: PK表示主键,FK表示外键</p><p>为了帮助理解,图2.5展示了图片列表的输出(只有一书本). 图书应用程序需要访问数据库中的每一张表来构建图书列表,后面我会使用代码进行查询显示</p><p><img src="https://img2018.cnblogs.com/blog/832799/201904/832799-20190424135430514-1319179356.png" referrerpolicy="no-referrer"></p><p>注: 你可以在 <a href="http://efcoreinaction.com/" target="_blank" rel="noopener">http://efcoreinaction.com/</a> 查看在线的示例,会有助于你理解本章的剩余部分,你也可以在Github仓库中找到这个示例在本地调试运行</p><h2 id="EF-Core映射数据库的类"><a href="#EF-Core映射数据库的类" class="headerlink" title="EF Core映射数据库的类"></a>EF Core映射数据库的类</h2><p>我创建5个类对应着灵气库中的5张表,分别是Book,PriceOffer,Review,Author和BookAuthor(多对多中间表)</p><p>这些类称之为实休类,以突出它们是由EF Core映射到数据库的. 从软件工程的角度来看实体类是普通的.Net类(有时也被称为POCO)并没有什么特别之处. 因为它们是EF Core映射到数据库中的类,所以对其与其他类区分,称为实体类</p><p>图书应用程序中主要的实体类是Book类,如下图所示. 它引用了PriceOffer类,Review类型的集合以及BookAuthor的集合</p><p><img src="https://img2018.cnblogs.com/blog/832799/201904/832799-20190424135525003-628834759.png" referrerpolicy="no-referrer"></p><p>我们使用了EF Core的约定配置实体类的主键,也就是类中int类型的Id属性. 数据库在添加新行时使用 Sql Identity 命令创建唯一键</p><p>为了保持示例的简单,示例中使用了EF Core的约定配置方法对数据库建模. .Net类的导航属性(比如ICollection<review>)定义了我需要关系类型,例如Reviews属性的类型是ICollection,所以是一对多关系. 第六章和第七章介绍了建模的其他方法</review></p><p>本文的示例介绍了如何通过EF Core定义和创建数据库,如果你已经有了一个现有数据库,可以使用EF Core的逆行工程数据库的功能根据数据库表构建DbContext类和实体类,在11.3节中会介绍到,如果你不希望EF Core更改数据库结果而是通过SQL脚本或数据库部署工具自己来管理,可以在11.4节中找到方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>查询数据库</title>
    <link href="https://liangsw.me/2019/03/06/queryingthedatabase/"/>
    <id>https://liangsw.me/2019/03/06/queryingthedatabase/</id>
    <published>2019-03-06T02:58:00.000Z</published>
    <updated>2019-04-24T06:04:48.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h2 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a><a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">第一部分目录导航</a></h2><h1 id="第二章查询数据库"><a href="#第二章查询数据库" class="headerlink" title="第二章查询数据库"></a>第二章查询数据库</h1><p>本章的内容有</p><ul><li>三种主要数据库关系类型的建模</li><li>使用迁移创建和更改数据库</li><li>定义和创建应用程序的DbContext</li><li>加载关联数据</li><li>将复杂查询拆分为子查询</li></ul><p>本章介绍了使用EF Core查询(读取)数据库,你将创建一个EF Core中三种主要数据库关系类型的数据库. 并且会学习如何通过EF Core创建和更改数据库结构</p><p>接下来,你将学习如何使用EF Core访问数据库,读取数据库表中的数据. 在学习使用主数据加载关系数据库的方式之前,我们会先学习EF Core查询的基本格式: 比如使用第一章的书籍加载作者数据</p><p>学习加载关联数据之后,将开始学习构建更复杂的查询完成图书电商网站的功能. 包括排序,过滤和分页,以及将这些单独的查询组合在一起创建复合查询的方法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>掀开EF Core的引擎盖看看EF Core内部是如何工作的</title>
    <link href="https://liangsw.me/2019/02/28/ShouldyouuseEFCoreinyournextproject/"/>
    <id>https://liangsw.me/2019/02/28/ShouldyouuseEFCoreinyournextproject/</id>
    <published>2019-02-28T06:02:00.000Z</published>
    <updated>2019-04-24T06:04:48.590Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h2 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a><a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">第一部分目录导航</a></h2><h1 id="应该在项目中使用EF-Core吗"><a href="#应该在项目中使用EF-Core吗" class="headerlink" title="应该在项目中使用EF Core吗?"></a>应该在项目中使用EF Core吗?</h1><p>在简单介绍了EF Core以及它的工作方式之后,接下来的问题是你是否应该在项目中开始使用EF Core. 对于想要使用EF Core的人来说,关键的问题是EF Core是否优与目前项目中使用的数据库访问库,简单的说就是它是否值得我们使用. 学习和使用新的类库都是有成本的,特别是像EF Core这样庞大复杂的库</p><p>我会给你一个详细的答案,正如你接下来看到的,我想更直观的描述. 图1.11展示了我对EF Core优缺点的看法: 优点在右边,缺点在左边. 每个块的宽度是我认为该部分被改善的时间段: 越宽花费的时间越长. 这只是我的观点,所以不要把它当做事实,我希望本书后续的内容可以帮助你思考EF Core对项目的影响</p><p><img src="https://img2018.cnblogs.com/blog/832799/201902/832799-20190228094520346-834200041.png" referrerpolicy="no-referrer"></p><p>让我们从优点开始,详细的介绍图1.11中的每一个块</p><h2 id="最新一代"><a href="#最新一代" class="headerlink" title="最新一代"></a>最新一代</h2><p>我从LINQ to SQL切换到了EF 4,因为EF是未来发展的方向,而LINQ to SQL不会再投入更多的精力. 现在的EF Core也是一样. 这是微软正在努力的方向,它会得到更多的扩展和更长的支持. EF Core比EF6.x更轻量,速度更快. 我认为它的API改进的很好</p><p>如果你正在启动一个新的项目,并且.NET Core和EF Core适用于你的项目,那么使用EF ore意味着你不会落后</p><h2 id="跨平台与开源"><a href="#跨平台与开源" class="headerlink" title="跨平台与开源"></a>跨平台与开源</h2><p>我在开章开始的时候提到EF Core支持跨平台,你可以在windows,linux和Apple上开发和运行EF Core应用程序. EF Core是开源的,你可以直接查看源码和问题与缺点列表 – 参见 <a href="https://github.com/aspnet/EntityFramework/issues" target="_blank" rel="noopener">https://github.com/aspnet/EntityFramework/issues</a></p><h2 id="快速开发"><a href="#快速开发" class="headerlink" title="快速开发"></a>快速开发</h2><p>在典型的数据驱动应用程序中,我编写了大量的数据库访问代码,有一些很复杂. 我发现EF6.x和现在的EF Core可以让我很简便快速的编写数据访问代码,并且易于理解与重构. 这是我使用EF的主要原因之一</p><p>EF Core对开发人员很友好,即使我没有编写最良好的代码也往往会创建有效的查询. 大部分格式正确的LINQ查询都可以正常工作,尽管它们可能无法被转换为性能最佳的SQL,不过一个正确有效的查询代码是一个很好的开始(我们可以再优化). 第12章介绍了性能调优的领域</p><h2 id="良好的文档与支持"><a href="#良好的文档与支持" class="headerlink" title="良好的文档与支持"></a>良好的文档与支持</h2><p>EF Core有完善的文档 (<a href="https://docs.microsoft.com/zh-cn/ef/core/index)" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/ef/core/index)</a>, 同样还有本书将文档与更深入的介绍和示例以及模式结合在一起,使你成为一名优秀的开发人员. 因为有很多EF 6.x的开发人员迁移到EF Core,互联网上有很多EF Core的博客,Stack Overflow可能已经有了你问题的解决方案</p><p>支持的另一部分是开发工具. 微软创建了免费Visual Studio Code跨平台开发环境. 微软还将Visual Studio免费提供了个人和小型企业</p><h2 id="通过Nuget包获取安装"><a href="#通过Nuget包获取安装" class="headerlink" title="通过Nuget包获取安装"></a>通过Nuget包获取安装</h2><p>尽管.NET Core 1出现了一些早期的困难,但2017年8月.Net Standard 2.0引入的.Net Framework兼容模式已经解决了大部分问题, 这就是EF Core 2.0构建的原因. .Net Standard 2.0允许早期(大多数).Net版本使用现有的Nuget库. 如果Nuget包使用了不兼容的功能(例如System.Reflection),则会出现问题. .Net Standard 2.0还支持更大范围的系统方法,这使将包转换为.Net Standard 2.0变的更容易</p><p>如果你的.Net框架版本是4.6.1或更多,那么你可以直接使用EF Core</p><h2 id="全功能的ORM"><a href="#全功能的ORM" class="headerlink" title="全功能的ORM"></a>全功能的ORM</h2><p>Entity Framework通常是O/RM的功能丰富的实现, EF Core将继续这一趋势. 它允许编写复杂的数据访问代码,涵盖了你想使用的大部分数据库的功能. 我使用过ADP.NET,LINQ to SQL, EF 4到6以及现在的EF Core, 我相信这已经是一个很棒的O/RM了</p><p>但是在编写本书时, EF Core(2.0)仍然有一些功能尚未添加, 这就是图1.11中的块如此宽的原因. 如果你使用过EF 6.x,你会注意到EF6.x的一些功能EF Core中还没有,但随着时间的推移,这些功能都会添加. 我建议你EF Core docs网站的功能比较页 <a href="http://mng.bz/ek4D" target="_blank" rel="noopener">http://mng.bz/ek4D</a>, 在这里可以了解到最新的进展</p><h2 id="稳定的类库"><a href="#稳定的类库" class="headerlink" title="稳定的类库"></a>稳定的类库</h2><p>当我开始写这个书时,EF Core还不稳定. 它有很多的缺陷和缺少的功能. 我发现1.0.0版本中使用DateTime的year存在错误, 还有1.1.0中修复的其他LINQ翻译的问题</p><p>当你在读到这篇文章时, EF Core已经修复了很多问题,但是仍在变化. 尽管速度要慢的多. 如果你想要稳定,可以选择EF6.x或其他数据库访问技术</p><h2 id="保持高性能"><a href="#保持高性能" class="headerlink" title="保持高性能"></a>保持高性能</h2><p>对于数据库性能问题,我不会说EF Core开箱即用,它拥有魔法可以生成漂亮的SQL和快速数据摄取带来极高的数据库访问性能. -.-这是不存在的!这是简便的代价: EF Core内部所有的”魔法”都不如手工编写的SQL好,但是你可能会惊讶它的魔法还是有点料的</p><p>幸运的是我们对此做一些措施.在我的项目中,我发现只有5%到10%的查询是需要手动调优的关键查询. 第12和13章以及第14章的一部分专门讨论性能调优. 我们有很多手段可以提高EF Core的数据库访问性能</p><p>如果你担心EF Core的性能,我建议你阅读13章,这一章中你会学习如何逐步提高应用程序的性能. 你将看到EF Core可以在很少的额外工作下运行良好. 我有两个演示站点  <a href="http://efcoreinaction.com" target="_blank" rel="noopener">http://efcoreinaction.com</a> 和  <a href="http://cqrsravendb.efcoreinaction.com" target="_blank" rel="noopener">http://cqrsravendb.efcoreinaction.com</a> ,在about菜单中可以看到数据库的大小</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>何时不应该使用EF Core</title>
    <link href="https://liangsw.me/2019/02/28/WhenshouldyounotuseEFCore/"/>
    <id>https://liangsw.me/2019/02/28/WhenshouldyounotuseEFCore/</id>
    <published>2019-02-28T06:02:00.000Z</published>
    <updated>2019-04-24T06:04:48.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h2 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a><a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">第一部分目录导航</a></h2><h1 id="何时不应该使用EF-Core"><a href="#何时不应该使用EF-Core" class="headerlink" title="何时不应该使用EF Core"></a>何时不应该使用EF Core</h1><p>显然我是EF Core的专业用户,但除非有意义否则我不会在客户项目中使用它,让我们看看一些可能不建议你使用的理由</p><p>第一个问题是显而易见的,它是否支持你使用的数据库? 你可以在<a href="https://docs.microsoft.com/zh-cn/ef/core/providers中找到支持的数据库列表" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/ef/core/providers中找到支持的数据库列表</a></p><p>第二个因素是你需要的性能级别. 如果你正在编写少量数据访问的一个小型的Restful服务,EF Core就不太适合了,你可以选择一个高性能但是需要写一些额外代码的库反正数据访问也不多. 但是如果你有一个中型或大型的应用程序,那么可以使用混合开发方式 (有关混合开发 EF Core/ Dapper应用程序的示例,请参见13章)</p><h2 id="本章概要"><a href="#本章概要" class="headerlink" title="本章概要"></a>本章概要</h2><ul><li>EF Core 是一个对象关系映射器(R/RM),它使用LINQ来定义数据库查询并将数据返回到.Net类的实例中</li><li>EF Core指在编写快速直观的数据库访问代码, 它有很多功能可以大部分的需求</li><li>使用EF Core有很多理由,它在EF的经验上重新设计,良好的文档与支持,跨平台</li><li>在写这本书时,EF Core是最新版是2.0, 你想要的一些功能可能尚未添加,你可以查看最新的文档实时关注 <a href="https://docs.microsoft.com/zg-cn/ef/core/index" target="_blank" rel="noopener">https://docs.microsoft.com/zg-cn/ef/core/index</a></li></ul><p>对于熟悉EF6.x的读者来说</p><ul><li>在书中找到EF 6的注释, 它们指出了EF Core与EF6.x之间的差异,也可以直接查看每章最后的概要,在这里指出了本章EF Core的变化</li><li>将EF Core看作是一个新的库,它的工作方式与EF 6.x不同. 这将帮助你发现EF Core的改进</li><li>EF Core不再支持EDMX/database designer的方式</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>掀开EF Core的引擎盖看看EF Core内部是如何工作的</title>
    <link href="https://liangsw.me/2019/02/26/LookingunderthehoodofEFCore/"/>
    <id>https://liangsw.me/2019/02/26/LookingunderthehoodofEFCore/</id>
    <published>2019-02-26T06:02:00.000Z</published>
    <updated>2019-04-24T06:04:48.534Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h2 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a><a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">第一部分目录导航</a></h2><h1 id="掀开EF-Core的引擎盖看看EF-Core内部是如何工作的"><a href="#掀开EF-Core的引擎盖看看EF-Core内部是如何工作的" class="headerlink" title="掀开EF Core的引擎盖看看EF Core内部是如何工作的"></a>掀开EF Core的引擎盖看看EF Core内部是如何工作的</h1><p>创建了MyFirstEfCoreApp应用程序后,你现在可以通过它查看EF Core的工作原理,重点不在于应用程序的代码,而是在读取和写入数据到数据库时EF Core内部会发生什么. 我的目标是让你了解EF Core的工作机制,当你深入研究本书其余部分的命令时,这会很有帮助</p><h2 id="数据库建模"><a href="#数据库建模" class="headerlink" title="数据库建模"></a>数据库建模</h2><p>在对数据库进行操作之前,EF Core必须进行数据库建模. 数据库建模是EF Core通过实体类和其他EF Core配置来描述数据库的方法. EF Core在所有的数据库访问中使用建立的模型</p><p>建模在创建应用程序的DbContext时就开始了,在本例中是AppDbContext(如图1.5所示,在上一篇文章中). 它有属性DbSet<book>,使得通过代码可以访问数据库</book></p><p>图1.6描述了建模过程的概述,它会帮助你理解EF Core数据库建模的过程. 后续的章节将介绍一系列配置数据库的相关命令,在本文中使用默认配置</p><p><img src="https://img2018.cnblogs.com/blog/832799/201902/832799-20190226095156685-307163266.png" referrerpolicy="no-referrer"></p><p>图1.6展示了EF Core在AppDbContext的建模步骤,下文对此过程进行更详细的说明</p><ol><li>EF Core查看DbContext并找到所有公共的DbSet<t>属性,并使用属性名为表定义初始名称.</t></li><li>EF Core查看DbSet<t>的泛型类,查看类的属性构建列名,类型等. 它还会查找类和属性用于提供额外建模配置的特殊Attribute</t></li><li>EF Core查找DbSet<t>类中引用的其他类. 在我们的例子中Book类有一个对Author类的引用,所以EF Core也会查看它. 它对Author类执行与步骤2相同的操作. 同时它使用类名Author做为表名</t></li><li>建模过程的最后一个步骤, EF Core运行DbContext的虚方法<code>OnModelCreating</code>, 可以通过重写<code>OnModelCreating</code>方法使用fluent Api进行更多的建模配置,但本例中为了保持示例的简单并没有这样做</li><li>EF Core根据收集的信息创建数据库的内部模型,并缓存数据库模式,以便提升访问速度. 在之后的所有的数据库访问中使用此模型</li></ol><p>你可能会注意到图1.6并没有展示数据库,因为EF Core构建内部模型时,<strong>它不会去查看数据库</strong>. 我强调这一点是为了说明构建一个的数据库模型多么重要,如果EF Core认为数据库模型和实际的数据库不匹配,就会出现问题</p><p>在你的应用程序中你可以使用EF Core来创建数据库,这会避免出现不匹配的情况. 如果你想要一个良好且高效的数据库,那么在你的代码中编写良好的数据库模型是非常重要的,这样创建的数据库会是高效的. 创建,更新和管理数据库结构是一个很大的主题,将在11章详细介绍</p><h2 id="从数据库中读取数据"><a href="#从数据库中读取数据" class="headerlink" title="从数据库中读取数据"></a>从数据库中读取数据</h2><p>现在可以访问数据库了. 我们使用List(l)命令,让程序读取数据库并在终端上打印信息. 图1.7显示了输出</p><p><img src="https://img2018.cnblogs.com/blog/832799/201902/832799-20190226102244267-1093071067.png" referrerpolicy="no-referrer"></p><p>下面列出代码清单, 用于将所有的图书与作者输出到控制台</p><p><img src="https://img2018.cnblogs.com/blog/832799/201902/832799-20190226103238572-1355908645.png" referrerpolicy="no-referrer"></p><p>EF Core使用Linq(语言集成查询)执行它想要执行的命令,使用.net类保存数据</p><p>代码清单中粗体显示的两行代码进行了数据库访问. 下面让我们看看EF Core如何使用Linq代码访问数据库并返回数据. 图1.8跟随着这些代码走进EF Core内部,看看不为人知的故事…</p><p><img src="https://img2018.cnblogs.com/blog/832799/201902/832799-20190226140616861-1403351889.png" referrerpolicy="no-referrer"></p><p>从数据库中读取数据的过程如下</p><ol><li>Linq查询中的<code>db.Books.AsNoTracking().Include(a =&gt; a.Author)</code>访问应用程序DbContext的DbSet<book>属性,<code>Include(a =&gt; a.Author)</code>显式加载关系的Author部分. 数据库提供程序将Linq翻译成访问数据库的SQL命令. SQL被缓存以便如果再次使用相同的查询语句时避免重新翻译的成本<br>EF Core在数据库访问方面会尽可能高效. 在这种情况下,它将需要读取的两张表(Books和Author)组合到一个大表中,在一次数据库访问中完成工作. 下面的清单展示了EF Core和数据库提供程序创建的SQL<br>SELECT [b].[BookId], [b].[AuthorId], [b].[Description], [b].[PublishedOn], [b].[Title], [a].[AuthorId], [a].[Name], [a].[WebUrl] FROM [Books] AS [b] INNER JOIN [Author] AS [a] ON [b].[AuthorId] = [a].[AuthorId]</book></li><li>数据库提供程序读取数据后,EF Core通过以下过程放置数据: (a) 创建.NET类的实例 (b) 使用数据库关系链接(外键),通过引用(称为关系修复)将.NET类链接在一起. 结果是一组以正确方式链接的.NET类实例. 在本例中两本书有相同的作者Martin Fowler,因此这两本书的作者属性指向同一个Author类</li><li>由于代码中包含 <code>AsNoTraching</code>, 所以EF Core知道禁止创建跟踪快照. 跟踪快照用于发现数据的变化, 你会在编辑WebUrl的示例中了解这一点. 由于这是一个只读查询,因此禁用跟踪快速会使查询更快</li></ol><h2 id="更新数据库"><a href="#更新数据库" class="headerlink" title="更新数据库"></a>更新数据库</h2><p>现在使用MyFirstEfCoreApp中的第二个命令update(u)来更新图书Quantum Networking作者的WebUrl列. 如图1.9所示,首先列出所有书籍,会看到最后一本书的作者没有WebUrl. 然后运行命令u,它将要求输入Url. 这时输入 <code>httqs://entangled.moon</code>(这是一个虚构的Url,httpqs-.-),在更新成功后再次列出所有的书籍,这时可以看到Web Url值已经更新</p><p><img src="https://img2018.cnblogs.com/blog/832799/201902/832799-20190226132527234-735969280.png" referrerpolicy="no-referrer"></p><p>代码清单</p><p><img src="https://img2018.cnblogs.com/blog/832799/201902/832799-20190226133234442-1057103695.png" referrerpolicy="no-referrer"></p><p>图1.10展示了EF Core内部发生了什么并跟踪其进度,这比上一个read的示例复杂许多, 因此我会给你一些提示</p><p>图顶部的读取阶段与上一个读取示例类似,所以应该很熟悉. 在此基础上使用图书的标题做为过滤器载特定的图书. 重要的是第2点: 对数据进行跟踪</p><p>在图的下半部分你可以看到EF Core如何将加载的数据与跟踪快照进行比较并找到更改,可以看到只有WebUrl被更新了,它创建了一个SQL命令来只更新该列</p><p><img src="https://img2018.cnblogs.com/blog/832799/201902/832799-20190226135002482-593136351.png" referrerpolicy="no-referrer"></p><p>图中已经描述了大部分步骤,下面介绍Author的WebUrl列如何更新的详细说明</p><ol><li>应用程序使用LINQ查找包含作者信息的单个图书,EF Core将LINQ查询翻译为SQL命令,读取Title为Quantum Networking的行,返回Book和Author类的实例,因为使用了<code>Single</code>查询,所以还会检查是否只找到一行</li><li>LINQ查询中没有<code>AsNoTracking</code>方法,所以该查询是一个具有跟踪的查询,EF Core创建了数据的跟踪快照</li><li>然后代码更改了Book的Author的WebUrl属性. 当调用SaveChanges时, 检测更改阶段会将跟踪的所有类与跟踪快照进行比较. 在这里它会检测到所有已更改的内容. 在本例中主鍵为3的Author实例的WebUrl属性值被更改</li><li>检测到更改后,EF Core将启动事务. 每个数据库更新都以原子单位完成: 更改全部成功或者全部失败. 这非常重要,因为如果仅应用了部分更改,关系数据库可能会发生严重的错误</li><li>更新请求由数据库提供程序转换为SQL命令,如果执行成功则提交事务并返回SaveChanges方法,否则会抛出异常</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>MyFirstEfCoreApp应用程序设置</title>
    <link href="https://liangsw.me/2019/02/19/settingefcorefiratapp/"/>
    <id>https://liangsw.me/2019/02/19/settingefcorefiratapp/</id>
    <published>2019-02-19T02:33:00.000Z</published>
    <updated>2019-04-24T06:04:48.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h2 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a><a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">第一部分目录导航</a></h2><h1 id="MyFirstEfCoreApp应用程序设置"><a href="#MyFirstEfCoreApp应用程序设置" class="headerlink" title="MyFirstEfCoreApp应用程序设置"></a>MyFirstEfCoreApp应用程序设置</h1><p>创建了.Net Core控制应用程序过后,现在可以编写EF Core代码了. 在编写数据库访问代码之前,你需要做两个重要的部分</p><pre><code>- EF Core将类映射到数据库中的表- 应用程序的DbContext,它是用于配置和访问数据库的主类</code></pre><h2 id="映射到数据库中的类-–-Book和Author"><a href="#映射到数据库中的类-–-Book和Author" class="headerlink" title="映射到数据库中的类 – Book和Author"></a>映射到数据库中的类 – Book和Author</h2><p>EF Core将类映射为数据库中的表. 因此你需要创建一个实体类,或者你已有一个数据库则需要匹配数据库表. 有很多的规则和配置(本书后面会介绍), 图1.4给出了映射到数据库表的实体类的一般格式</p><p><img src="https://img2018.cnblogs.com/blog/832799/201902/832799-20190219133128699-2089779371.png" referrerpolicy="no-referrer"></p><p>下面是<code>Author</code>实体类的定义,它的结构与Book类相同,主键遵循EF Core命名约定(参见第6.3.15节). Book类有一个名为AuthorId的属性,EF Core将它视为外键,因为它与Author实体的主键同名</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Author</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> AuthorId <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">string</span> Name <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">string</span> WebUrl <span class="token punctuation">{</span> <span class="token keyword">get</span><span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="应用程序中的DbContext-数据库上下文"><a href="#应用程序中的DbContext-数据库上下文" class="headerlink" title="应用程序中的DbContext(数据库上下文)"></a>应用程序中的DbContext(数据库上下文)</h2><p>另一个重要的部分是应用程序的DBContext. 这是继承自EF Core的DbContext的类. 它包含EF Core配置数据库所需的信息,也是在代码中访问数据库时使用的类(参见 1.9.2节). 图1.5展示了MyFirstEfCoreApp控制台应用使用的DbContext (名为AppDbContext)</p><p><img src="https://img2018.cnblogs.com/blog/832799/201902/832799-20190219142533619-1479719161.png" referrerpolicy="no-referrer"></p><p>在我们的小型示例中,建模的所有细节都是由EF Core完成的,它通过使用约定来解决问题. 你有很多其他方法告诉EF Core数据库模型的配置,这些命令会让这个小示例变的复杂,所以暂时不做介绍. 在第6章和第7章中介绍了所有的配置选择</p><p>本示例中使用了一种方法定义控制台应用程序的DbContext: 覆盖应用程序的DbContext的OnConfiguring方法,提供EF Core需要的数据库类型和连接字符串等其他信息. 这种方法的缺点是它的连接字符串是固定的,不利于单元测试</p><p>在ASP.NET Core应用程序中这是一个问题, 因为在不同的环境: 开发,测试,生产我们会使用不同的数据库. 在第2章中我们将构建一个ASP.NET Core Web应用程序,将会使用一个不同的方式来更改数据库连接字符串(参见2.2.2节)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>FirstEFCoreApp访问的数据库</title>
    <link href="https://liangsw.me/2019/02/01/firstEfCoreApp&#39;s_database/"/>
    <id>https://liangsw.me/2019/02/01/firstEfCoreApp&#39;s_database/</id>
    <published>2019-02-01T02:33:00.000Z</published>
    <updated>2019-04-24T06:04:48.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h2 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a><a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">第一部分目录导航</a></h2><h1 id="MyFirstEfCoreApp访问的数据库"><a href="#MyFirstEfCoreApp访问的数据库" class="headerlink" title="MyFirstEfCoreApp访问的数据库"></a>MyFirstEfCoreApp访问的数据库</h1><p>EF Core是访问数据库的技术,但是数据库从何而来呢?EF Core提供了两个选择:EF Core为你构建数据库称为 <code>Code First</code>,或者在外部(DBMS)构建数据库称为<code>Db First</code></p><pre><code>EF6 在EF6中可以使用`EDMX`数据库设计器可视化的设计数据库,称为`Design First`. 但是EF Core并不支持也没有计划添加</code></pre><p>本章跳过了创建数据库的部分,我们假设它已经存在</p><pre><code>NOTE 在代码中我使用了用于单元测试的EF Core命令创建了数据库,因为它简单方便. 第2章介绍了使用EF Core创建数据库,第11章介绍了创建和更改数据库的所有方面</code></pre><p>对于<code>MyFirstEfCoreApp</code>应用,我创建了一个只有两个表的简单数据库,如图1.2所示:</p><pre><code>NOTE Books表名来自应用程序 DbContext 中 DbSet&lt;Book&gt; 的属性名称,`DbContext`没有Author表的DbSet&lt;T&gt;属性,所以使用类名做为默认名称. 6.10.1节详细的介绍了配置规则.`</code></pre><p><img src="https://img2018.cnblogs.com/blog/832799/201902/832799-20190202092020019-1404494573.png" referrerpolicy="no-referrer"></p><ol><li>一个存放书籍信息的<code>Books</code>表</li><li>书籍作者的<code>Author</code>表</li></ol><p>图1.3展示了数据库的内容,共有四本书,前两本书的作者是Martin Fowler</p><p><img src="https://img2018.cnblogs.com/blog/832799/201902/832799-20190202093123394-475339597.png" referrerpolicy="no-referrer"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>第一个EF Core应用程序</title>
    <link href="https://liangsw.me/2019/02/01/firstEfCore/"/>
    <id>https://liangsw.me/2019/02/01/firstEfCore/</id>
    <published>2019-02-01T02:33:00.000Z</published>
    <updated>2019-04-24T06:04:48.523Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h2 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a><a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">第一部分目录导航</a></h2><h1 id="你的第一个EF-Core应用程序"><a href="#你的第一个EF-Core应用程序" class="headerlink" title="你的第一个EF Core应用程序"></a>你的第一个EF Core应用程序</h1><p>在本章你会从一个简单的示例开始,这样我们就可以专注观察EF Core而不是代码做了什么. 本章会带领你编写一个名为 <code>MyFirstEfCoreApp</code> 的简单控制台应用程序,它访问一个同样简单的数据库. <code>MyFirstEfCoreApp</code>的功能是列出与更新书籍</p><p>图1.1展示了控制台输出</p><p><img src="https://img2018.cnblogs.com/blog/832799/201902/832799-20190201101822099-1546394943.png" referrerpolicy="no-referrer"></p><p>这个应用程序足够简单,是一个很好的起点,很适合我向你展示EF Core的内部工作原理,以便帮助你理解本书后面的内容</p><p>你可以在github仓库 <a href="http://mng.bz/KTjz" target="_blank" rel="noopener">http://mng.bz/KTjz</a> 第一章的分支上下载这个示例程序,查看代码并运行程序</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>你可以使用Visual Studio 2017(VS2017)或 Visual Studio Code(VS Code)开发.Net Core应用程序. 在本书我使用了VS2017,因为它对.Net开发新手比较友好</p><p>你需要从 <a href="http://www.visualstudio.com" target="_blank" rel="noopener">www.visualstudio.com</a> 下载安装VS2017. vs2017有很多版本, community版是免费的, 不过你需要阅读许可证确保自己符合条件; 见 <a href="http://www.visualstudio.com/vs/community/" target="_blank" rel="noopener">www.visualstudio.com/vs/community/</a></p><p>安装VS2017时,确保勾选了.Net Core跨平台开发. 它会在系统中安装配置.Net Core开发环境. 安装完毕后就可以构建.Net Core应用程序了. 更多信息请查看 <a href="http://mng.bz/2x0T" target="_blank" rel="noopener">http://mng.bz/2x0T</a></p><h2 id="创建使用EF-Core的-Net-Core控制台应用程序"><a href="#创建使用EF-Core的-Net-Core控制台应用程序" class="headerlink" title="创建使用EF Core的.Net Core控制台应用程序"></a>创建使用EF Core的.Net Core控制台应用程序</h2><p>很多开发人员都喜欢从零构建自己的代码,所以本章详细介绍了使用VS2017创建.Net Core应用程序</p><p>你也可以在Github上直接下载已有的代码 <a href="http://mng.bz/KTjz" target="_blank" rel="noopener">http://mng.bz/KTjz</a></p><h3 id="创建-Net-Core控制台应用程序"><a href="#创建-Net-Core控制台应用程序" class="headerlink" title="创建.Net Core控制台应用程序"></a>创建.Net Core控制台应用程序</h3><p>第一步是使用VS 2017创建一个.Net Core控制台应用程序,步骤如下:</p><ol><li>点击VS2017顶部的文件按钮 &gt; 新键  &gt; 项目 &gt; 打开新键项目页面</li><li>在已安装模板中选择 Visual C# =&gt; .Net Core &gt; 控制台使用 (.Net Core)</li><li>输入 <code>MyFirstEfCoreApp</code> 做为程序名称,默认VS 2017的保存目录是 <code>C:\Users\admin\Source\Repos</code></li><li>确保 <code>为解决方案创建目录</code> 框已勾选,以便应用程序拥有自己的文件夹</li><li>如果你希望为项目创建Git repo,可以勾选 <code>新建Git仓库</code>. 然后单击确定</li></ol><p>这时一个控制台应用程序已经创建成功</p><h3 id="添加EF-Core类库到应用程序"><a href="#添加EF-Core类库到应用程序" class="headerlink" title="添加EF Core类库到应用程序"></a>添加EF Core类库到应用程序</h3><p>你需要安装EF Core类库, <code>Microsoft.EntityframeworkCore.SqlServer</code> 是很好的选择,在安装VS 2017时已经自带了开发版的SqlServer</p><p>可以通过多种方式安装Nuget包,最直观的方式是使用Nuget包管理器</p><ol><li>右键项目选择<code>管理NuGet程序包</code></li><li>在出现的页面中搜索 <code>Microsoft.EntityFrameworkCore.SqlServer</code>,然后找到匹配的Nuget包并安装到项目</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>关于NoSql</title>
    <link href="https://liangsw.me/2019/01/29/whataboutnosql/"/>
    <id>https://liangsw.me/2019/01/29/whataboutnosql/</id>
    <published>2019-01-29T07:33:00.000Z</published>
    <updated>2019-04-24T06:04:48.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h2 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a><a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">第一部分目录导航</a></h2><h1 id="关于NoSql"><a href="#关于NoSql" class="headerlink" title="关于NoSql"></a>关于NoSql</h1><p>在讨论关系型数据库时,我们不能不提到非关系型数据库,也就是NoSQL(参见 <a href="http://mng.bz/DW63)" target="_blank" rel="noopener">http://mng.bz/DW63)</a>. 关系型数据库和非关系型数据库在现代应用程序中都扮演着重要的角色,我在一个应用程序中同时使用了Sql Server(关系型数据库)和Azure表(非关系数据库)来处理不同的业务需求</p><p>EF Core被设计为处理关系型数据库和非关系型数据库,与EF 6.x不同,后面只围绕着关系型数据库而设计. 本书介绍的许多原则适用与这两种数据库,但是由于关系型数据库本质上比非关系型数据库复杂许多,因此使用关系型数据库需要更多的命令. 你会在一整章中看到专门介绍仅在关系型数据库中使用的命令. 例如第7章的内容就是关系数据库建模</p><p>EF Core 2.0包含Azure NoSql数据库和Cosmos DB的预览数据库驱动程序. 目的是做为为学习处理NoSQL数据库的练习, 并在EF Core 2.2提供了更强大的解决方案. 随着时间的推移,无论是微软还是NoSql数据库的作者都可以为EF Core编写更多的NoSql数据库驱动程序</p><p>注: 在14.2节中介绍了在命令查询职责分离(CQRS)模式中使用SQL/ 关系型数据库和NoSQL数据库构建应用程序,使应用程序的性能更高</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>EF Core 概述</title>
    <link href="https://liangsw.me/2019/01/27/overviewofEFCore/"/>
    <id>https://liangsw.me/2019/01/27/overviewofEFCore/</id>
    <published>2019-01-27T07:04:00.000Z</published>
    <updated>2019-04-24T06:04:48.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h2 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a><a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">第一部分目录导航</a></h2><h1 id="EF-Core-概述"><a href="#EF-Core-概述" class="headerlink" title="EF Core 概述"></a>EF Core 概述</h1><p>EF Core可以用作O/RM, 它在关系型数据库和包含类与软件代码的.NET软件之间进行映射. 表1.1展示了EF Core如何映射关系型数据库和.NET软件</p><p><img src="https://img2018.cnblogs.com/blog/832799/201901/832799-20190127133839715-1013108214.png" referrerpolicy="no-referrer"></p><h2 id="O-RM的缺陷"><a href="#O-RM的缺陷" class="headerlink" title="O/RM的缺陷"></a>O/RM的缺陷</h2><p>编写一个优秀的O/RM很复杂的,尽管EF6.x或EF Core很容易使用,但有时EF Core的”魔法”会让你大吃一惊(surprise -.-),在我们深入了解EF Core的工作原理之前,我需要先提一下两个需要注意的问题</p><p>第一个问题是对象关系抗阻不匹配. 数据库服务器和面向对象的软件使用了不同的规则: 数据库使用主键来定义行是唯一的,而.Net类实例的引用在默认情况下被认为是唯一的. EF Core会为你处理大部分内容,但是你的.Net类会被这些键(主键)”污染”,它们的值很重要.虽然大多数情况下EF Core都可以很好的处理,但有时你不得不做一些与纯软件解决方案不同的处理方式.你会在第2章看到一个多对多关系的例子:在C#中很容易,但在数据库中需要多做一些处理</p><p>第二个问题是O/RM(尤其是EF Core这样全面的O/RM)将数据库隐藏的深,以至于你有时会忘记数据库中会发生什么,这可能会导致你编写的代码在测试应用中没有什么问题,但是来到了实际的生产环境,当数据库很复杂并且有很多并发用户时,执行的效率会很低下</p><p>这就是为什么我会花时间在本章中展示EF Core的工作原理以及它生成的SQL. 对EF Core了解的更多,就越能够编写更好的EF Core代码,更重要的是当出现问题时知道怎么分析</p><p>注: 在本书中,我使用 “让EF Core正常工作,但如果我需要,会让它的性能变的更快”的方法来使用EF Core.EF Core让我们快速开发,但由于EF Core的缺陷或我对它的不良使用导致了数据库访问代码的性能不足以满足特定业务需求. 第5章介绍了如何隔离EF Core在最小的代价下对其优化,第13章介绍了如何查找和改进性能低下的数据库访问代码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>对正在使用EF6x开发人员的一些话</title>
    <link href="https://liangsw.me/2019/01/27/forEF6.x/"/>
    <id>https://liangsw.me/2019/01/27/forEF6.x/</id>
    <published>2019-01-27T06:33:00.000Z</published>
    <updated>2019-04-24T06:04:48.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h2 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a><a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">第一部分目录导航</a></h2><h1 id="对正在使用EF6x开发人员的一些话"><a href="#对正在使用EF6x开发人员的一些话" class="headerlink" title="对正在使用EF6x开发人员的一些话"></a>对正在使用EF6x开发人员的一些话</h1><p><strong>如果你是EF新手,可以跳过这一节</strong></p><p>如果你是经验丰富的EF6.x开发者,那么你会熟悉EF Core的大部分内容,为了帮助你快速浏览本书,我添加了EF6的注释</p><pre><code>**EF6** 在书中注意这样的注释,它们指出了EF Core与EF 6.x的不同之处. **另外一定要看每章结尾的总结**.它们在指出了本章了EF6与EF Core之间最大的变化</code></pre><p>另外还有一个建议,因为我对EF6非常熟悉,我在使用EF Core的过程这成了一个问题. 因为我总是使用EF6.x的方式解决问题,却没有注意到EF Core有新的解决方法.大多种情况下没有问题,但是<strong>并非总是如此</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>你将在本书中学到什么</title>
    <link href="https://liangsw.me/2019/01/27/WhatlearnfromEFCoreinAction/"/>
    <id>https://liangsw.me/2019/01/27/WhatlearnfromEFCoreinAction/</id>
    <published>2019-01-27T05:33:00.000Z</published>
    <updated>2019-04-24T06:04:48.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h2 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a><a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">第一部分目录导航</a></h2><h1 id="你将从本书中学到什么"><a href="#你将从本书中学到什么" class="headerlink" title="你将从本书中学到什么"></a>你将从本书中学到什么</h1><p>本书分为3个部分. 除本章外,第1部分有还其他4章.</p><p>内容包括:</p><ul><li>使用EF Core 查询数据库</li><li>使用EF Core 更改数据库(创建,更新和删除)</li><li>在业务逻辑中使用EF Core</li><li>构建一个使用EF Core的ASP.NET Core web应用程序</li></ul><p>在第1部分结束时,你应该能够构建使用关系型数据库的.NET应用程序. 但是数据库的组织方式留给了EF Core,例如EF Core的默认配置设置数据库列的类型和大小(可能会浪费空间).</p><p>第2部分将介绍如何以及为什么可以更改默认值,并深入了解一些EF Core命令.学习完第2部分后,你将能够使用EF Core以你希望的方式创建数据库,或者连接到特定架构或设计的现有数据库. 使用EF Core的一些高级功能更改数据库的数据在.NET应用程序中的把暴露方式,例如更仔细地控制软件对数据的访问或构建代码自动跟踪数据库更改</p><p>第3部分是关于提高你的EF Core技能, 使你成为更优秀的开发和调试人员. 我将介绍使用EF Core的实例, 从一系列的已知模式和实践开始,你将学习有关EF Core应用程序的单元测试和EF Core扩展. 第3部分最重要的部分是查找和修复EF Core性能的章节</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>介绍EF Core</title>
    <link href="https://liangsw.me/2019/01/27/IntroductionEFCore/"/>
    <id>https://liangsw.me/2019/01/27/IntroductionEFCore/</id>
    <published>2019-01-27T04:33:00.000Z</published>
    <updated>2019-04-24T06:04:48.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h2 id="第一部分目录导航"><a href="#第一部分目录导航" class="headerlink" title="第一部分目录导航"></a><a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">第一部分目录导航</a></h2><h1 id="第1章-Entity-Framework-Core-简介"><a href="#第1章-Entity-Framework-Core-简介" class="headerlink" title="第1章 Entity Framework Core 简介"></a>第1章 Entity Framework Core 简介</h1><p>Entity Framework Core在以下的介绍中若无特别说明均使用EF Core代替. EF Core是允许开发人员访问数据库的类库,有很多种方式去编写这样的类库例如Dapper,但是EF Core被设计为<code>object-relational mapper</code> (O/RM). O/RM通过在两个世界之间的映射来工作: 具有自己API的关系型数据库和包含类与软件代码的面向对象软件世界. EF Core的主要优势在于开发人员可以快速的编写数据库访问代码</p><p>微软在2016年发布了支持多平台的EF Core, 它可以在windows,linux和Apple上运行,它是.NET core计划的一部分,因此EF Core名称中的Core部分就是由此而来. (但是EF Core也可以和现有的.NET Framework一起使用 - 请参阅1.10.5节中的说明). EF Core,ASP.NET Core(Web服务端应用程序)和.NET Core都是开源的,在Github上每一个项目都有一个issues页面用于与它们的开发团队讨论</p><p>EF Core不是Entity Framework的第一个版本; 现有的非Core版本从4到6.x版本积累了多年的经验和反馈, 它保持了与EF6.x相同的接口类型.但是在底层有一些重大的变化,比如处理非关系型数据库的能力设计与EF6.x是不同的. 作为EF5和EF6的前用户,我可以看到EF Core在哪些地方进行了改进,以及它仍然缺少我喜欢的EF6.x库的功能(虽然这些功能在路线路上正在开发)</p><p>本书面向的是从未使用过EF和经验丰富的EF6x开发人员,以及想要了解EF Core的人.本书假设读者已经熟悉C#,Net开发,并且对关系型数据库有所了解,不需要你了解如何编写结构化查询语言(SQL),因为EF Core可以为你完成大部分工作,但是我在书中展示了EF Core生成的SQL,因为它能帮助你理解;使用EF Core的一些高级功能需要你具备SQL知识,不过书中提供了大量的图表帮助你理解</p><p>本章通过使用EF Core的小应用向你介绍EF Core, 你将在本章中学习到EF Core如何解释命令并访问数据库,了解EF Core的工作原理对阅读本书其余部分会有帮助</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>EF Core in Action 关于这本书</title>
    <link href="https://liangsw.me/2019/01/25/aboutentityframeworkcoreinaction/"/>
    <id>https://liangsw.me/2019/01/25/aboutentityframeworkcoreinaction/</id>
    <published>2019-01-25T07:33:00.000Z</published>
    <updated>2019-04-24T06:04:48.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><p>第一部分目录<a href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/">导航</a></p><h2 id="关于这本书"><a href="#关于这本书" class="headerlink" title="关于这本书"></a>关于这本书</h2><p>本书的目的是让读者掌握如何快速,正确的编写EF Core数据库访问代码,并实现高性能. 围绕着 “快速、正确、性能” 这些方面,我提供了大量的示例,其中包含大量的技巧和技术. 在讲解的过程中,我加入了很多EF Core内部原理的内容,因为当数据库访问代码无法按照预期工作时,这些将会帮助你进行分析. 微软的文档也是学习Entity Framework Core不错的选择,但是它没有提供详细的示例. 在本书中,我尝试为每个功能提供一个示例,你会在Git仓库中找到单元测试代码(参见 “关于代码” 部分的链接). 有时阅读单元测试代码会比书中的内容更容易理解,所以单元测试是一种有用的资源.</p><h3 id="本书适合什么样的读者"><a href="#本书适合什么样的读者" class="headerlink" title="本书适合什么样的读者"></a>本书适合什么样的读者</h3><p>本书面向的是从未使用过EF和经验丰富的EF6x开发人员,以及想要了解EF Core的人. 本书假设读者已经熟悉C#,Net开发,并且对关系型数据库有所了解, 不要求对C#多太过深入的了解,但是如果你初学C#,可能会发现有些代码难以阅读,因为我不会讲解C#,但我会提供一个关于Linq(语言集成查询)的附录</p><h3 id="本书内容是如何组织的"><a href="#本书内容是如何组织的" class="headerlink" title="本书内容是如何组织的"></a>本书内容是如何组织的</h3><p>本书的路径是从基础(第1部分)开始,深入理解(第2部分),最后以实用的工具和技术(第3部分)结束<br>我不会假设读者从头到尾的阅读这本书,但至少略读前5章会帮助读者理解我在书中后面使用到的基础知识</p><h4 id="Part-1-基础"><a href="#Part-1-基础" class="headerlink" title="Part 1 : 基础"></a>Part 1 : 基础</h4><p>第1章通过第一个简单的控制台应用介绍EF core,你将看到EF Core的每个部分. 我还概述了EF Core的工作原理以及为什么你会爱上它.</p><p>第2章介绍了查询(从数据库中读取数据),我将介绍存储在数据库中的数据之间的关系,以及如何使用EF Core加载相关数据</p><p>第3章介绍了更改数据库中的数据: 添加、更新、删除</p><p>第4章介绍了如何使用EF Core构建健壮的业务逻辑数据库访问代码,业务逻辑是应用程序解决<code>特定业务问题</code>时所实现的<code>业务规则或工作流代码</code>的<strong>名称</strong></p><p>第5章是关于构建使用EF Core的ASP.Net Core应用程序,它汇总了第2章到第4章的内容创建了一个Web应用程序,我还谈到了部署Web应用程序和访问托管数据库</p><h3 id="Part-2-深入理解Entity-Framework-core"><a href="#Part-2-深入理解Entity-Framework-core" class="headerlink" title="Part 2 : 深入理解Entity Framework core"></a>Part 2 : 深入理解Entity Framework core</h3><p>第6章介绍了配置非关系属性 – 包含值(如int、string、DateTime等)的属性</p><p>第7章介绍了关系的配置– 类之间的关系, 例如Book包含一个或多个Author. 还讲解了特殊的映射方式,例如将多个类映射到一个表</p><p>第8章介绍了高级映射功能以及检测和处理并发冲突</p><p>第9章深入讨论EF Core的DbContext的工作原理,并逐一介绍应用程序的DbContext中各个方法和属性的作用</p><h3 id="Part-3-在真实的应用程序中使用Entity-Framework-Core"><a href="#Part-3-在真实的应用程序中使用Entity-Framework-Core" class="headerlink" title="Part 3 : 在真实的应用程序中使用Entity Framework Core"></a>Part 3 : 在真实的应用程序中使用Entity Framework Core</h3><p>第10章是工具,模式和技巧的概要,可以让你使用EF Core更快速的开发和使代码更加健壮,我还介绍了如何在领域驱动设计方法中使用EF Core</p><p>第11章介绍了使用EF Core时更改数据库结构的所朋方式,它还包括当你更改实时应用程序所使用的数据库结构时出现的问题</p><p>第12章列出了所有可能影响数据库访问性能的问题以及如何处理它们</p><p>第13章是一个优化EF Core应用程序性能的示例,我使用第1部分中开发的图书应用程序进行三个级别的性能调优</p><p>第14章从介绍更改数据库类型时会发生什么开始,然后介绍一种可以提升某些业务应用程序性能的程序架构,最后以访问和修改EF Core的内部服务结束</p><p>第15章是关于使用EF Core进行单元测试的应用程序,我还创建了一个nuget包,你可以使用它帮助你进行单元测试</p><p>注: 我在书的章节中都添加了有关EF Core2.1特性的注释,这些指出了2.1版在哪些方面相比较EF 2.0有了新选择</p><h2 id="关于代码"><a href="#关于代码" class="headerlink" title="关于代码"></a>关于代码</h2><p>我觉得,只有编写代码才会真正的对某些功能或特性有深入的理解. 在git仓库中每章甚至章的部分都有一个自己的分支, 仓库地址可以在这里找到 <a href="https://github.com/liangshiw/EfCoreInAction" target="_blank" rel="noopener">https://github.com/liangshiw/EfCoreInAction</a> (原地址: <a href="https://github.com/JonPSmith/EfCoreInAction)" target="_blank" rel="noopener">https://github.com/JonPSmith/EfCoreInAction)</a>. 有关更多信息,请参见git仓库Readme的 <code>在哪里找到代码</code> 部分 <a href="https://github.com/liangshiw/EfCoreInAction/blob/master/README.md#wheres-the-code" target="_blank" rel="noopener">https://github.com/liangshiw/EfCoreInAction/blob/master/README.md#wheres-the-code</a> (原地址: <a href="https://github.com/JonPSmith/EfCoreInAction/blob/master/README.md#wheres-the-code" target="_blank" rel="noopener">https://github.com/JonPSmith/EfCoreInAction/blob/master/README.md#wheres-the-code</a>)</p><p>注: 第15章内容是关于单元测试的,它有自己的git仓库 <a href="https://github.com/liangshiw/EfCore.TestSupport" target="_blank" rel="noopener">https://github.com/liangshiw/EfCore.TestSupport</a> (原地址:  <a href="https://github.com/JonPSmith/EfCore.TestSupport" target="_blank" rel="noopener">https://github.com/JonPSmith/EfCore.TestSupport</a>)<br>我之所以将它与前14章分开是因为它包含的工具和功能可以帮助你进行单元测试,你还可以将 <code>EfCore.TestSupport</code> 包安装到你的项目中,使用我在15章中描述的功能</p><p>编写代码或运行git仓库中的代码,你需要以下内容</p><p><strong>开发环境</strong> (我对原文进行了简化)</p><ul><li>Visual Studio 2017</li><li>也可以使用Visual Studio Code,我在每个分支中设置了.vscode目录,可以正确的构建,测试和运行代码</li><li>.Net Core SDK</li></ul><p>注: git仓库太多使用的是.Net Core 2.0,但是我将一些分支更新到了.Net Core 2.1,参见 <a href="https://github.com/liangshiw/EfCoreInAction#net-core-21-examples" target="_blank" rel="noopener">https://github.com/liangshiw/EfCoreInAction#net-core-21-examples</a> (原地址: <a href="https://github.com/JonPSmith/EfCoreInAction#net-core-21-examples" target="_blank" rel="noopener">https://github.com/JonPSmith/EfCoreInAction#net-core-21-examples</a>)</p><h2 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h2><p>以下是微软文档,EF Core源码和其他有用的资源的链接</p><ul><li>微软 EF Core 文档:  <a href="https://docs.microsoft.com/zh-cn/ef/core/index" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/ef/core/index</a> </li><li>EF Core路线图: <a href="https://github.com/aspnet/EntityFrameworkCore/wiki/roadmap" target="_blank" rel="noopener">https://github.com/aspnet/EntityFrameworkCore/wiki/roadmap</a> </li><li>EF Core源码: <a href="https://github.com/aspnet/EntityFrameworkCore" target="_blank" rel="noopener">https://github.com/aspnet/EntityFrameworkCore</a> </li><li>ASP.NET Core与EF Core共同使用的教程: <a href="https://docs.microsoft.com/zh-cn/aspnet/core/data/" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/aspnet/core/data/</a> </li><li>Stack Overflow EF Core tag: [entity-framework-core] <a href="https://stackoverflow.com" target="_blank" rel="noopener">https://stackoverflow.com</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>EF Core in Action 目录导航</title>
    <link href="https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/"/>
    <id>https://liangsw.me/2019/01/24/Entityframeworkcoreinactiontoc/</id>
    <published>2019-01-24T11:33:00.000Z</published>
    <updated>2019-05-07T11:39:04.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Entity-Framework-Core-in-Action"><a href="#Entity-Framework-Core-in-Action" class="headerlink" title="Entity Framework Core in Action"></a>Entity Framework Core in Action</h1><p><strong>Entityframework Core in action是 <code>Jon P smith</code> 所著的关于Entityframework Core 书籍。<a href="https://www.manning.com/books/entity-framework-core-in-action" target="_blank" rel="noopener">原版地址</a>. 是除了官方文档外另一个学习EF Core的不错途径, 书中由浅入深的讲解的EF Core的相关知识。因为没有中文版,所以本人对其进行翻译。 预计每两天一篇更新 PS: 翻译难免限于本人水平有不准确的地方，建议英文水平不错的同学直接查看原版，有不足的地方欢迎指正</strong></p><h1 id="第一部分-入门-目录导航"><a href="#第一部分-入门-目录导航" class="headerlink" title="第一部分 入门 目录导航"></a>第一部分 入门 目录导航</h1><p><a href="https://liangsw.me/2019/01/24/aboutentityframeworkcoreinaction/">关于这本书</a></p><h2 id="1-Entity-Framework-Core-简介"><a href="#1-Entity-Framework-Core-简介" class="headerlink" title="1 Entity Framework Core 简介"></a><a href="https://liangsw.me/2019/01/27/IntroductionEFCore">1 Entity Framework Core 简介</a></h2><p> <a href="https://liangsw.me/2019/01/27/WhatlearnfromEFCoreinAction">1.1 你将从本书中学到什么</a></p><p> 1.2 作者与EF Core的故事,与技术无关不做翻译</p><p> <a href="(https://liangsw.me/2019/01/27/forEF6.x">1.3 对正在使用EF6x开发人员的一些话</a> TODO</p><p> <a href="https://liangsw.me/2019/01/27/overviewofEFCore">1.4 EF Core 概述</a></p><p> <a href="https://liangsw.me/2019/01/29/whataboutnosql">1.5 关于NoSql</a></p><p> <a href="https://liangsw.me/2019/02/01/firstEfCore">1.6 你的第一个EF Core程序</a></p><p> <a href="https://liangsw.me/2019/02/02/firstEfCoreApp&#39;s_database">1.7 MyFirstEfCoreApp访问的数据库</a></p><p> <a href="https://liangsw.me/2019/02/19/settingefcorefiratapp">1.8 配置MyFirstEfCoreApp应用程序</a></p><p> <a href="https://liangsw.me/2019/02/26/LookingunderthehoodofEFCore">1.9 掀开EF Core的引擎盖看看EF Core内部是如何工作的</a></p><p> <a href="https://liangsw.me/2019/02/28/ShouldyouuseEFCoreinyournextproject">1.10 应该在项目中使用EF Core 吗</a></p><p> <a href="https://liangsw.me/2019/02/28/WhenshouldyounotuseEFCore">1.11 何时不应该使用EF Core</a></p><h2 id="2-查询数据库"><a href="#2-查询数据库" class="headerlink" title="2 查询数据库"></a><a href="https://liangsw.me/2019/03/06/queryingthedatabase">2 查询数据库</a></h2><p> <a href="https://liangsw.me/2019/04/24/Settingthesceneourbook-sellingsite">2.1 设置一个图书销售网站的场景</a></p><p> <a href="https://liangsw.me/2019/04/25/Creatingtheapplication’sDbContext">2.2 创建应用程序的DbContext</a></p><p> <a href="https://liangsw.me/2019/04/26/Understandingdatabasequeries">2.3 理解数据库查询</a></p><p> <a href="https://liangsw.me/2019/05/07/Loadingrelateddata">2.4 加载相关数据</a></p><p> <a href>2.5 使用客户端与服务器评估: 将部分查询移动到软件中</a> TODO</p><p> <a href>2.6 构建复杂的查询</a> TODO</p><p> <a href>2.7 添加排序,过滤和分页</a> TODO</p><p> <a href>2.8 把它们放在一起: 组合查询对象</a> TODO</p><h2 id="3-更改数据库内容-TODO"><a href="#3-更改数据库内容-TODO" class="headerlink" title="3 更改数据库内容 TODO"></a><a href>3 更改数据库内容</a> TODO</h2><p> <a href>3.1 EF Core 实体状态</a> TODO</p><p> <a href>3.2 向表中添加数据</a> TODO</p><p> <a href>3.3 更新一条数据</a> TODO</p><p> <a href>3.4 处理在更新中的实体间的关系</a> TODO</p><p> <a href>3.5 删除实体</a> TODO</p><h2 id="4-在业务逻辑中使用EF-Core-TODO"><a href="#4-在业务逻辑中使用EF-Core-TODO" class="headerlink" title="4 在业务逻辑中使用EF Core TODO"></a><a href>4 在业务逻辑中使用EF Core</a> TODO</h2><p> <a href>4.1 为什么业务逻辑与其它代码不同</a> TODO</p><p> <a href>4.2 假定业务- 处理书籍订单</a> TODO</p><p> <a href>4.3 使用设计模式帮助实现业务逻辑</a> TODO</p><p> <a href>4.4 实现处理书籍订单的实现逻辑</a> TODO</p><p> <a href>4.5 在图书应用上创建订单</a> TODO</p><p> <a href>4.6 为业务逻辑处理中添加额外的功能</a> TODO</p><h2 id="5-在Asp-Net-Core-Web应用程序中使用EF-Core-TODO"><a href="#5-在Asp-Net-Core-Web应用程序中使用EF-Core-TODO" class="headerlink" title="5 在Asp.Net Core Web应用程序中使用EF Core TODO"></a><a href>5 在Asp.Net Core Web应用程序中使用EF Core</a> TODO</h2><p> <a href>5.1 Asp.Net Core 简介</a> TODO</p><p> <a href>5.2 理解图书应用程序的架构</a> TODO</p><p> <a href>5.3 理解依赖注入</a> TODO</p><p> <a href>5.4 通过DI使应用程序的DbContext可用</a> TODO</p><p> <a href>5.5 在Asp.Net Core中调用数据库访问代码</a> TODO</p><p> <a href>5.6 添加图书清单查询页面</a> TODO</p><p> <a href>5.7 将数据库方法实现为DI服务</a> TODO</p><p> <a href>5.8 部署Asp.Net Core 应用程序与数据库</a> TODO</p><p> <a href>5.9 使用EF Core 迁移更改数据库结构</a> TODO</p><p> <a href>5.10 使用async/await获取更好的可伸缩性(吞吐量)</a> TODO</p><p> <a href>5.11 运行并行任务时如何提供DbContext</a> TODO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Entity-Framework-Core-in-Action&quot;&gt;&lt;a href=&quot;#Entity-Framework-Core-in-Action&quot; class=&quot;headerlink&quot; title=&quot;Entity Framework Core in Actio
      
    
    </summary>
    
    
      <category term="Entity Framework Core" scheme="https://liangsw.me/tags/Entity-Framework-Core/"/>
    
  </entry>
  
  <entry>
    <title>Logdashboard1.1-beta</title>
    <link href="https://liangsw.me/2019/01/23/Logdashboard1.1-beta/"/>
    <id>https://liangsw.me/2019/01/23/Logdashboard1.1-beta/</id>
    <published>2019-01-23T11:33:00.000Z</published>
    <updated>2019-04-24T06:04:48.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Logdashboard-1-1beta-在AspNetMvc中使用日志面板"><a href="#Logdashboard-1-1beta-在AspNetMvc中使用日志面板" class="headerlink" title="Logdashboard 1.1beta. 在AspNetMvc中使用日志面板"></a>Logdashboard 1.1beta. 在AspNetMvc中使用日志面板</h1><p>Logdashboard是Net下的日志面板,它支持AspNet与AspNetCore项目。关于更多LogDashboard的介绍请看<a href="https://www.cnblogs.com/LiangSW/p/10233047.html" target="_blank" rel="noopener">这里</a>。</p><p>就在刚刚LogDashboard发布了1.1的beta版,在这个版本中有以下变化<br><a href="https://github.com/liangshiw/LogDashboard/releases" target="_blank" rel="noopener">https://github.com/liangshiw/LogDashboard/releases</a></p><ul><li>支持NetFramework的AspNetMvc项目</li><li>走势图添加更多趋势</li><li>支持serilog日志组件</li><li>异步查询日志</li></ul><h2 id="在AspNetMvc中使用日志面板"><a href="#在AspNetMvc中使用日志面板" class="headerlink" title="在AspNetMvc中使用日志面板"></a>在AspNetMvc中使用日志面板</h2><p>示例源码 : <a href="https://github.com/liangshiw/LogDashboard/tree/master/samples/NfxAspNetMvc" target="_blank" rel="noopener">https://github.com/liangshiw/LogDashboard/tree/master/samples/NfxAspNetMvc</a></p><p>使用VisualStudio创建一个AspNetMvc项目,命名为 <code>NfxAspNetMvc</code></p><h3 id="配置Nlog"><a href="#配置Nlog" class="headerlink" title="配置Nlog"></a>配置Nlog</h3><p>在程序包管理控制台安装 Nlog.Web<br><code>Install-Pakcage Nlog.Web</code></p><p>将下面的Nlog.config添加到项目中,并且配置复制到目录</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span> <span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span>nlog xmlns<span class="token operator">=</span><span class="token string">"http://www.nlog-project.org/schemas/NLog.xsd"</span>      xmlns<span class="token punctuation">:</span>xsi<span class="token operator">=</span><span class="token string">"http://www.w3.org/2001/XMLSchema-instance"</span>      autoReload<span class="token operator">=</span><span class="token string">"true"</span>      throwExceptions<span class="token operator">=</span><span class="token string">"false"</span>      internalLogLevel<span class="token operator">=</span><span class="token string">"Off"</span> internalLogFile<span class="token operator">=</span><span class="token string">"c:\temp\nlog-internal.log"</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> optional<span class="token punctuation">,</span> <span class="token keyword">add</span> some variables  https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>nlog<span class="token operator">/</span>NLog<span class="token operator">/</span>wiki<span class="token operator">/</span>Configuration<span class="token operator">-</span>file#variables  <span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">&lt;</span>variable name<span class="token operator">=</span><span class="token string">"myvar"</span> <span class="token keyword">value</span><span class="token operator">=</span><span class="token string">"myvalue"</span><span class="token operator">/</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>  See https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>nlog<span class="token operator">/</span>nlog<span class="token operator">/</span>wiki<span class="token operator">/</span>Configuration<span class="token operator">-</span>file  <span class="token keyword">for</span> information on customizing logging rules and outputs<span class="token punctuation">.</span>   <span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">&lt;</span>targets<span class="token operator">></span>    <span class="token operator">&lt;</span>target xsi<span class="token punctuation">:</span>type<span class="token operator">=</span><span class="token string">"file"</span> name<span class="token operator">=</span><span class="token string">"File"</span> fileName<span class="token operator">=</span><span class="token string">"${basedir}/logs/${shortdate}.log"</span>            layout<span class="token operator">=</span><span class="token string">"${longdate}||${level}||${logger}||${message}||${exception:format=ToString:innerFormat=ToString:maxInnerExceptionLevel=10:separator=\r\n}||end"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>    Write events to a file with the date <span class="token keyword">in</span> the filename<span class="token punctuation">.</span>    <span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>targets<span class="token operator">></span>  <span class="token operator">&lt;</span>rules<span class="token operator">></span>    <span class="token operator">&lt;</span>logger name<span class="token operator">=</span><span class="token string">"*"</span> minlevel<span class="token operator">=</span><span class="token string">"Debug"</span> writeTo<span class="token operator">=</span><span class="token string">"file"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> <span class="token keyword">add</span> your logging rules here <span class="token operator">--</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>    Write all events with minimal level of <span class="token function">Debug</span> <span class="token punctuation">(</span>So Debug<span class="token punctuation">,</span> Info<span class="token punctuation">,</span> Warn<span class="token punctuation">,</span> Error and Fatal<span class="token punctuation">,</span> but not Trace<span class="token punctuation">)</span>  to <span class="token string">"f"</span>    <span class="token operator">&lt;</span>logger name<span class="token operator">=</span><span class="token string">"*"</span> minlevel<span class="token operator">=</span><span class="token string">"Debug"</span> writeTo<span class="token operator">=</span><span class="token string">"f"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">--</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>rules<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>nlog<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打开<code>WebConfig</code> 将下面的modules节点配置复制到 <code>WebConfig</code>中</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token operator">&lt;</span>modules runAllManagedModulesForAllRequests<span class="token operator">=</span><span class="token string">"true"</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token keyword">remove</span> name<span class="token operator">=</span><span class="token string">"TelemetryCorrelationHttpModule"</span> <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token keyword">add</span> name<span class="token operator">=</span><span class="token string">"TelemetryCorrelationHttpModule"</span> type<span class="token operator">=</span><span class="token string">"Microsoft.AspNet.TelemetryCorrelation.TelemetryCorrelationHttpModule, Microsoft.AspNet.TelemetryCorrelation"</span> preCondition<span class="token operator">=</span><span class="token string">"integratedMode,managedHandler"</span> <span class="token operator">/</span><span class="token operator">></span>      <span class="token operator">&lt;</span><span class="token keyword">add</span> name<span class="token operator">=</span><span class="token string">"NLog"</span> type<span class="token operator">=</span><span class="token string">"NLog.Web.NLogHttpModule, NLog.Web"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>modules<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打开 <code>HomtController</code> 使用logger 写一条日志</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> ActionResult <span class="token function">Index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//var logger = logger</span>    <span class="token keyword">var</span> logger <span class="token operator">=</span> LogManager<span class="token punctuation">.</span><span class="token function">GetCurrentClassLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    logger<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span><span class="token string">"HomeController index action"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">View</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="安装LogDashboard"><a href="#安装LogDashboard" class="headerlink" title="安装LogDashboard"></a>安装LogDashboard</h3><p>logDashboard在AspNetMvc中依赖<code>Owin</code>中间件,首先我们先安装 <code>Microsoft.Owin.Host.SystemWeb</code> 包</p><p><code>Install-Package Microsoft.Owin.Host.SystemWeb</code></p><p>下面安装LogDashboard 因为是预发布版,在安装的时候需要指定版本</p><p><code>Install-Package LogDashboard -Version 1.1.0-beta</code></p><p>最后我们添加Owin Startup类,在添加时搜索owin会出现该条目,在Startup中配置LogDashboard中间件</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">Configuration</span><span class="token punctuation">(</span>IAppBuilder app<span class="token punctuation">)</span><span class="token punctuation">{</span>    app<span class="token punctuation">.</span><span class="token function">MapLogDashboard</span><span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>Startup<span class="token punctuation">)</span><span class="token punctuation">.</span>Assembly<span class="token punctuation">,</span> opt <span class="token operator">=</span><span class="token operator">></span>    <span class="token punctuation">{</span>        opt<span class="token punctuation">.</span><span class="token function">SetRootPath</span><span class="token punctuation">(</span>AppContext<span class="token punctuation">.</span>BaseDirectory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时运行项目并导航到 <code>/logdashboard</code> 就会看到日志面板,与我们添加的日志消息 <code>HomeController index action</code></p><p><img src="https://img2018.cnblogs.com/blog/832799/201901/832799-20190123182457412-997077935.png" referrerpolicy="no-referrer"></p><h2 id="走势图"><a href="#走势图" class="headerlink" title="走势图"></a>走势图</h2><p>在1.1中添加了以小时、天、周、月为单位的日志趋势图</p><p><img src="https://img2018.cnblogs.com/blog/832799/201901/832799-20190123182603280-2136954267.gif" referrerpolicy="no-referrer"></p><h2 id="支持serilog"><a href="#支持serilog" class="headerlink" title="支持serilog"></a>支持serilog</h2><p>除了log4net、Nlog之外 LogDashboard还加入了serilog的支持与示例</p><p>示例源码：<a href="https://github.com/liangshiw/LogDashboard/tree/master/samples/UseSerilog" target="_blank" rel="noopener">https://github.com/liangshiw/LogDashboard/tree/master/samples/UseSerilog</a><br>大家可以自行下载体验</p><h2 id="异步查询日志"><a href="#异步查询日志" class="headerlink" title="异步查询日志"></a>异步查询日志</h2><p>我fork了 <a href="https://github.com/tmsmith/Dapper-Extensions" target="_blank" rel="noopener">https://github.com/tmsmith/Dapper-Extensions</a> ,添加了NetStandard版本的异步查询支持,并发布了Nuget包 <a href="https://www.nuget.org/packages/DapperExtensions.Standard/" target="_blank" rel="noopener">https://www.nuget.org/packages/DapperExtensions.Standard/</a><br>在LogDashboard中实现了数据库的异步查询</p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p><a href="https://logboard.lpflipped.xin/" target="_blank" rel="noopener">Logdashboard官网</a></p><p><a href="https://logboard.lpflipped.xin/doc/index.html" target="_blank" rel="noopener">LogDashboard文档</a></p><p><a href="https://github.com/liangshiw/LogDashboard" target="_blank" rel="noopener">仓库地址</a></p><p>欢迎入群交流</p><p><img src="https://user-images.githubusercontent.com/16813853/51227366-df111580-198e-11e9-9e0c-f7b077e63fe7.png" referrerpolicy="no-referrer"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Logdashboard-1-1beta-在AspNetMvc中使用日志面板&quot;&gt;&lt;a href=&quot;#Logdashboard-1-1beta-在AspNetMvc中使用日志面板&quot; class=&quot;headerlink&quot; title=&quot;Logdashboard 1.1
      
    
    </summary>
    
    
      <category term="aspnetcore" scheme="https://liangsw.me/tags/aspnetcore/"/>
    
      <category term="logdashboard" scheme="https://liangsw.me/tags/logdashboard/"/>
    
  </entry>
  
  <entry>
    <title>Abp中使用可视化的日志面板</title>
    <link href="https://liangsw.me/2019/01/17/Use%20LogDashboard%20in%20Abp/"/>
    <id>https://liangsw.me/2019/01/17/Use LogDashboard in Abp/</id>
    <published>2019-01-17T10:33:00.000Z</published>
    <updated>2019-04-24T06:04:48.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abp中使用可视化的日志面板"><a href="#Abp中使用可视化的日志面板" class="headerlink" title="Abp中使用可视化的日志面板"></a>Abp中使用可视化的日志面板</h1><p>如果你还不了解LogDashboard请看<a href="https://www.cnblogs.com/LiangSW/p/10233047.html" target="_blank" rel="noopener">这里</a>。<br>ABP的相关知识不做介绍如果有需要请阅读<a href="https://aspnetboilerplate.com/Pages/Documents" target="_blank" rel="noopener">ABP官方文档</a></p><p>ABP是Net下非常优秀的开发框架,在中国很多的项目都正在使用它。现在我们可以使用LogDashboard增强在使用ABP开发中的查看日志能力。</p><h2 id="下载ABP模板项目"><a href="#下载ABP模板项目" class="headerlink" title="下载ABP模板项目"></a>下载ABP模板项目</h2><p>打开浏览器导航到 <a href="https://aspnetboilerplate.com/Templates" target="_blank" rel="noopener">https://aspnetboilerplate.com/Templates</a> , 下载一个NetCore版本的MPA项目模板,项目名为 <code>UseLogDashboardinAbp</code></p><p><img src="https://img2018.cnblogs.com/blog/832799/201901/832799-20190118100817564-563164862.png" referrerpolicy="no-referrer"></p><p>剩下的流程是打开解决方案运行迁移等.. 不做介绍暂且跳过。</p><h2 id="安装程序包"><a href="#安装程序包" class="headerlink" title="安装程序包"></a>安装程序包</h2><p>将 <code>UseLogDashboardinAbp.Web.Mvc</code> 项目设置为启动项目, 打开程序包管理控制台并将默认项目设置为 <code>UseLogDashboardinAbp.Web.Mvc</code> 运行以下命令</p><p><code>Install-Package LogDashboard</code></p><p>ABP默认使用的是Log4net日志组件,我们需要对<code>log4net.config</code>做一些调整,使用下面的配置覆盖默认的log4net.config的配置</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token operator">&lt;</span>file <span class="token keyword">value</span><span class="token operator">=</span><span class="token string">"App_Data/Logs/Logs.log"</span> <span class="token operator">/</span><span class="token operator">></span><span class="token operator">&lt;</span>conversionPattern <span class="token keyword">value</span><span class="token operator">=</span><span class="token string">"%date || %5level || %logger || %message || %exception ||end %newline"</span> <span class="token operator">/</span><span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>完整的log4net.config 如下</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"utf-8"</span> <span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span>log4net<span class="token operator">></span>  <span class="token operator">&lt;</span>appender name<span class="token operator">=</span><span class="token string">"RollingFileAppender"</span> type<span class="token operator">=</span><span class="token string">"log4net.Appender.RollingFileAppender"</span> <span class="token operator">></span>    <span class="token operator">&lt;</span>file <span class="token keyword">value</span><span class="token operator">=</span><span class="token string">"App_Data/Logs/Logs.log"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>appendToFile <span class="token keyword">value</span><span class="token operator">=</span><span class="token string">"true"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>rollingStyle <span class="token keyword">value</span><span class="token operator">=</span><span class="token string">"Size"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>maxSizeRollBackups <span class="token keyword">value</span><span class="token operator">=</span><span class="token string">"10"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>maximumFileSize <span class="token keyword">value</span><span class="token operator">=</span><span class="token string">"10000KB"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>staticLogFileName <span class="token keyword">value</span><span class="token operator">=</span><span class="token string">"true"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>layout type<span class="token operator">=</span><span class="token string">"log4net.Layout.PatternLayout"</span><span class="token operator">></span>      <span class="token operator">&lt;</span>conversionPattern <span class="token keyword">value</span><span class="token operator">=</span><span class="token string">"%date || %5level || %logger || %message || %exception ||end %newline"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>layout<span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>appender<span class="token operator">></span>  <span class="token operator">&lt;</span>root<span class="token operator">></span>    <span class="token operator">&lt;</span>appender<span class="token operator">-</span><span class="token keyword">ref</span> <span class="token keyword">ref</span><span class="token operator">=</span><span class="token string">"RollingFileAppender"</span> <span class="token operator">/</span><span class="token operator">></span>    <span class="token operator">&lt;</span>level <span class="token keyword">value</span><span class="token operator">=</span><span class="token string">"DEBUG"</span> <span class="token operator">/</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>root<span class="token operator">></span>  <span class="token operator">&lt;</span>logger name<span class="token operator">=</span><span class="token string">"NHibernate"</span><span class="token operator">></span>x`    <span class="token operator">&lt;</span>level <span class="token keyword">value</span><span class="token operator">=</span><span class="token string">"WARN"</span> <span class="token operator">/</span><span class="token operator">></span>  <span class="token operator">&lt;</span><span class="token operator">/</span>logger<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>log4net<span class="token operator">></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="配置LogDashboard服务-amp-中间件"><a href="#配置LogDashboard服务-amp-中间件" class="headerlink" title="配置LogDashboard服务&amp;中间件"></a>配置LogDashboard服务&amp;中间件</h2><p>首先打开 <code>Startup.cs</code> 文件</p><h3 id="配置服务"><a href="#配置服务" class="headerlink" title="配置服务"></a>配置服务</h3><p>在 <code>ConfigureServices</code> 方法中配置服务</p><pre class="line-numbers language-csharp"><code class="language-csharp">services<span class="token punctuation">.</span><span class="token function">AddLogDashboard</span><span class="token punctuation">(</span>opt <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>    opt<span class="token punctuation">.</span><span class="token function">SetRootPath</span><span class="token punctuation">(</span>Path<span class="token punctuation">.</span><span class="token function">Combine</span><span class="token punctuation">(</span>_env<span class="token punctuation">.</span>ContentRootPath<span class="token punctuation">,</span> <span class="token string">@"App_Data/Logs"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="配置中间件"><a href="#配置中间件" class="headerlink" title="配置中间件"></a>配置中间件</h3><p>在 <code>Configure</code> 中的 <code>UseMvc</code> 上方添加以下代码</p><pre class="line-numbers language-csharp"><code class="language-csharp">app<span class="token punctuation">.</span><span class="token function">UseLogDashboard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p>至此已经完成所有配置,现在运行 <code>UseLogDashboardinAbp.Web.Mvc</code> 项目 导航到 <code>logdashboard</code></p><p><img src="https://img2018.cnblogs.com/blog/832799/201901/832799-20190118104816535-858890856.png" referrerpolicy="no-referrer"></p><p>日志面板已经呈现在浏览器中</p><p><img src="https://img2018.cnblogs.com/blog/832799/201901/832799-20190118112118697-1163392391.png" referrerpolicy="no-referrer"></p><h2 id="More"><a href="#More" class="headerlink" title="More"></a>More</h2><p><a href="https://logboard.lpflipped.xin/" target="_blank" rel="noopener">Logdashboard官网</a></p><p><a href="https://logboard.lpflipped.xin/doc/index.html" target="_blank" rel="noopener">LogDashboard文档</a></p><p><a href="https://github.com/liangshiw/LogDashboard" target="_blank" rel="noopener">仓库地址</a></p><p>欢迎入群交流</p><p><img src="https://user-images.githubusercontent.com/16813853/51227366-df111580-198e-11e9-9e0c-f7b077e63fe7.png" referrerpolicy="no-referrer"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Abp中使用可视化的日志面板&quot;&gt;&lt;a href=&quot;#Abp中使用可视化的日志面板&quot; class=&quot;headerlink&quot; title=&quot;Abp中使用可视化的日志面板&quot;&gt;&lt;/a&gt;Abp中使用可视化的日志面板&lt;/h1&gt;&lt;p&gt;如果你还不了解LogDashboard请看&lt;
      
    
    </summary>
    
    
      <category term="aspnetcore" scheme="https://liangsw.me/tags/aspnetcore/"/>
    
      <category term="logdashboard" scheme="https://liangsw.me/tags/logdashboard/"/>
    
      <category term="ABP" scheme="https://liangsw.me/tags/ABP/"/>
    
  </entry>
  
</feed>
