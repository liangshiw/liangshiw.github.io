<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>设计模式 “续” | liangsw</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="liangsw"><meta name="keywords" content="netcore, net, 梁士伟, liangshiwei, 程序员, 后端开发, 全栈开发"><meta name="description" content="我叫梁士伟,专注.Net最佳实践。实践毋庸置疑,我们生来就具有基因所赋予的做出各种行为的潜能,但这些潜能变成实际能力的方式取决于我们所受的训练,取决于学习"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="https://liangsw.me/2016/12/26/设计模式 “续”/index.html"><link rel="icon" type="image/png" href="/img/favicon.ico" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="liangsw"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?5eba754c0c03b69141924e36e27a68c9";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-124492593-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-124492593-1")</script><link rel="stylesheet" href="/scss/views/page/post.css"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"><link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body ontouchstart><div id="page-loading" class="page page-loading" style="background-image:url(https://img2018.cnblogs.com/blog/832799/201901/832799-20190116134700976-47612090.gif)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="https://img2018.cnblogs.com/blog/832799/201901/832799-20190116143132379-773150053.jpg" referrerpolicy="no-referrer" alt="设计模式 “续”"></div><header class="post__info"><h1 class="post__title">设计模式 “续”</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/">梁士伟</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2016-12-26</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/设计模式/">设计模式</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-eye"></i><ul class="mark__list clearfix"><li id="busuanzi_container_page_pv" class="mark__item"><span id="busuanzi_value_page_pv"></span>次</li></ul></div></div></header><div class="post__content"><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>再次申明，本文学习自 程杰 兄的 “大话设计模式” 根据书中的内容和自己的体会而来。</p><p>观察者模式也叫 发布、订阅模式，在这个模式里，一个目标物件管理所有依赖它的观察者物件，在本身状态更改时发出通知，通知将被观察者接收到。</p><p>书中用例子 炒股 来形容了这一点，在炒股的同事是观察者，依赖于前台妹子。当老板来的时候向炒股的同事发出通知，但是问题是 前台妹子与炒股的同事耦合在一起，这并不符合依赖倒置原则。所以把发布者与观察者都进行抽象，它们都依赖于抽象，这样就解开了之间的关系。</p><p>解决了依赖问题，但是新的问题又来了，因为不是所有的观察者方法名都是一样的，都叫 Update可能不是很严谨，而且在使用别人的代码的时候这些就不是你能控制的了。使用委托，把方法做为参数代入发布者的通知方法则可以解决这下问题。</p><p>这种模式通常被用在实现事件处理系统，当一个对象的改变需要同时改变其它对象，而且它不知道具体有多少对象待改变时。</p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>从简单工厂、工厂、到抽象工厂，都是为了解决客户端或者调用类与被调用类的依赖，以防后期需求变更需要更换很多的代码。比如之前是使用sqlserver，现在变成了mysql，那么就要把使用了sqlserver的地方统统更改成mysql。依赖倒置原则让抽象不应该依赖于细节，细节应该依赖于抽象。但是这里明显就是依赖了细节。</p><p>抽象工厂解决了依赖的问题</p><p>一个抽象工厂的接口</p><p>sqlserver的工厂与mysql的工厂继承自抽象工厂接口，返回各自的实现（实现继承自接口，实际是返回接口,这样客户端就不用管你是什么实现）</p><p>这要对于调用者而已，它只需要知道IFactory就可以，但是虽然解决了依赖的问题，但是又违背了 开放、封闭原则 。因为如果有新的功能添加进来，我们除了要添加实现接口提供实现还要去修改工厂内的逻辑或者说提供一个获取实现的方法，新加一个新的功能成本是很高的。</p><p>所以这就是属于<strong>过度设计</strong>，当一个设计不能让自己感到使用愉快的时候，那就是过度设计。无论是是sqlserver还是使用mysql我都不想要关心，什么劳子工厂我也不想写这么多，我只想要一个符合我需求的实现类</p><p>使用简单工厂去改造抽象工厂</p><pre><code>*  去掉抽象工厂接口  
*  去除劳子工厂  
*  提供一个类返回我想要的实现的方法（这里还是返回接口，怎么精简，这里都精简不掉了，否则就失去了设计的意义）
</code></pre><p>想要正确的返回，根据是sqlserver还是mysql，还是绕不开switch case 判断 ，判断是sqlserver就返回sqlserver的实现，当然这是不好的，书中提供了一个方式是使用反射，使用变量或者写入到xml中，比如变量中存的是sqlserver</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">static</span> IUser <span class="token function">GetUserManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

    <span class="token comment" spellcheck="true">// Manager.SqlServerUser</span>

    <span class="token keyword">string</span> className <span class="token operator">=</span> “Manager<span class="token punctuation">.</span>”<span class="token operator">+</span>db<span class="token operator">+</span>“User”<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span>IUserManager<span class="token punctuation">)</span>Assembly<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span>“Manager”<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">CreateInstance</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其实说了这么多，最佳实践还是IOC，也就是依赖注入。当然上面也是依赖注入的一种，但是，现在各种IOC容器可以完美的帮我们解决这些问题，使用简单粗暴功能又强大。上面这么麻烦的事情 -.- 哈哈，还算了吧</p><p>IOC容器</p><ol><li>AutoFac</li><li>Ninject</li><li>Untity(微软亲儿子)</li><li>CastleWindsor</li></ol><h1 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h1><p>啊，又是一个深得我心的设计模式。假如有一个功能，但是前提是需要根据订单的状态来进行后面的操作 ，于是代码会出现下面这种情况，相信每个人都是感同身受，if else等分支语句是为开发带来了很多好处，但是往往会让代码臃肿不堪。</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">if</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span>Stats<span class="token operator">==</span>OrderSstats<span class="token punctuation">.</span>OK<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true">//todo....</span>
<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span>Stats<span class="token operator">==</span>OrderStats<span class="token punctuation">.</span>NoPay<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true">//todo....</span>
<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span>Stats<span class="token operator">==</span>OderStats<span class="token punctuation">.</span>Expired<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment" spellcheck="true">//todo....</span>
<span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代码的坏味道就像是厨师炒菜时放了半袋盐，虽然可以吃。但是很不好吃，对于这情况已经有很了很多的解决方式，而状态模式针对这种坏味道的最佳选择之一，状态模式主要解决的是当控制一个对象的状态转换条件表达式过于复杂时的情况，把状态的判断逻辑转移到表示不同状态的一系统类当中，可以把复杂的逻辑判断简化、</p><p>定义抽象状态类 state 其中有抽象方法 handle 供子类实现</p><p>在子类状态类中对<br><strong>单一</strong><br>的某个状态进行判断，如果不符合则设置下一个状态，并且移交下一个状态类进行处理</p><p>维护状态类的context类</p><p>继续拿上面的例子做演示，用了状态模式后。我们需要定义一个抽象状态类</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">State</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> abstrat <span class="token keyword">void</span> <span class="token function">Handle</span><span class="token punctuation">(</span>Order order<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>像OK、Nopay、Expired 的判断则是三个状态子类</p><pre class="line-numbers language-csharp"><code class="language-csharp"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PayOkStats</span><span class="token punctuation">:</span>State
<span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">override</span> <span class="token keyword">void</span> <span class="token function">Handle</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
         <span class="token keyword">if</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span>Order<span class="token punctuation">.</span>Stats<span class="token operator">==</span>Order<span class="token punctuation">.</span>OK<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//todo.....</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span>
        <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//设置下一状态,并且移交下个状态类去处理</span>
            context<span class="token punctuation">.</span><span class="token function">SetStats</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">NoPayStats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>context<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>人们忘说亡羊补牢为时不晚，确实在已经发生这种事情后，把牢补上可以避免以后再发生类似的事，但是如果在建牢的时候就建筑的牢固那不就不会亡羊也不用再去补牢。</p><p>但是既然有亡羊补牢的典故，代码中也会有这种类似的情况，项目急着上线，但是后台接口又不兼容。这时就需要迅速给出一个补救方法。使用适配器模式做出兼容的接口供调用，让项目快速上线。</p><p>系统的数据和行为都正确，但接口不符时，我们应该考虑使用适配器，目的是使控制范围之外的一个原有对象与某个接口匹配，适配器模式主要应用于希望复用一些现存的类，但是接口又与复用环境要示不一致的情况</p><p>假如有一个订单接口，某个app需要用到订单中的某个字段但是原有的接口又没有提供，订单获取的逻辑又复杂且冗长，直接拷贝一个一样的方法显的很不好，使用适配器模式包装旧接口使其输出与我们需要的一致。</p><p>但是如果有时间的话，还是花时间去重构最好 ，毕竟不能每到紧急的时候靠适配器来补牢</p><h1 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h1><p>在我们做项目的时候，也许会遇到这样的情况，也就是某个对象的某细信息我们要暂时的存储起来，后面再进行恢复。就像是游戏中的存档。也许我们会创建一个新的对象，把信息存起来，也许会用几个变量存起来。如果有五六个字段需要存储的话，那么代码立即就会出来坏味道了。</p><p>面向对象中的封装要时刻的记起来，这些 备份 ，恢复的细节都存在我们的代码中，我们需要把它们封装起来。也就是可以使用设计模式中的备忘录模式</p><p>备忘录类，里面有我们需要进行存储的字段属性</p><p>对象类中需要有方法，存储信息、恢复信息方法。存储信息方法把数据给备忘录对象，恢复则是从备忘录把数据读取出来再赋值给自己</p><p>管理者类，管理备忘录类</p><p>也不是说所有的这种情况都要加上备忘录模式、模式加多了也会拖慢开发效率，比如如果对象所有的字段都需要进行备份呢？我们直接使用克隆模式就可以了，模式再好，还是要看是否适合，硬套上去，不如不套</p><h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><p>组合模式理会的不是很透彻，这里标个记号，以后再慢慢体会吧</p><p>书中原话 组合模式将对象组合成树形结构以表示 部分-整体 的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。需求中是体现部分与整体层次的结构时，以及用户可以忽略组合对象和单个对象的不同，统一地使用组合结构中所有对象时，就应该考虑使用组合模式了。</p><p>也就是二叉树的关系，可以无限的往下分节点，但是树叶是不可以再分的。在组合模式中树叶往往是功能而不是对象</p><p>比如现在的超市都是连锁的，办了一个超市的会员卡，在其它的分店中使用都是可以被使用的，有个需求在总店消费的积分在其它分店也是进行加分的，而在其它的分店中消费只可以在本省内的店中进行增加积分</p><p>对于用户来说，他的行为只是消费，而超市的功能是增加积分，所有的分店都有的功能。但是因为地域问题，总不能让用户到一个城市办一张会员卡吧，对于用户来说，我不想知道你是什么劳子总店还是分店或者是哪个省的店，我只是想买个东西而已。</p><p>抽象类、Add、Remove 方法添加节点要移除，以及节点的共有行为 比如增加积分</p><p>枝节点….</p><p>叶节点</p><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>当写着 foreach 的时候不禁感叹，遍历对象如此简单。用起来如此爽快，即使我们想要实现迭代器也是很简单的一件事，只需要实现IEnumerable接口即可。</p><p>而这个迭代器模式似乎越来越被忘却，倒是如果看到了这一模式，会觉得似乎IEnumerable也是迭代器模式的一种实现，但是做的更好。是的，目前的高级语言C#、Java等都内置了迭代器</p><p>迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。</p><h1 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h1><p>单例是使用广泛且大多程序员都知道的一个设计模式，比如EF的上下文对象，我们一般都是线程内单例的。除了有助于性能，还为事务带来了方便。</p><p>单例，顾名思义也就是只有一个实例。</p><p>饿汉式单例 程序初始化或请求进入时就创建对象。不管是否使用</p><p>懒汉式单例 只有在使用的时候才进行创建对象且返回</p><p>一般来的单例设计，都是把类的构造方法修饰为private，然后提供一个静态方法去获取对象。方法里只new一次，如果有实例了则直接返回</p><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><p>不得不提一下 组合/聚合原则 尽量使用合成/聚合 尽量不要使用类继承</p><p>组合关系是表示一个强的拥有关系，比如艾斯奥特曼，那变身的一男一女就是组合，没了对方谁也无法成为奥特曼</p><p>聚合则不同，M78星云有一堆奥特曼。奥特曼在m78星云。也就是奥特曼是M78星云的一部分这是没有疑问的，但是不可以说M78星云是奥特曼的一部分</p><p>又是一个深得我心的原则 ，而桥接模式似乎是聚合原则的最佳实现</p><p>优先使用对象的合成/聚合将有助于保持每个类被封装，并被集中在单个任务上，这样类和类的继承层次会保持较小的规模，并且不太可能增长为不可控制的庞然大物。</p><p>继续拿我们的奥特曼举例子，M78星云有很多的奥特曼，我们可以有一个奥特曼父类</p><p>每个奥特曼都有奥义，比如躺着发射激光，站着发射激光，扔出飞镖等等</p><pre class="line-numbers language-csharp"><code class="language-csharp">奥特曼父类    奥义方法

赛文奥特曼：奥特曼父类

赛文奥特曼发射激光子类

      奥义<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>发射激光<span class="token punctuation">}</span>

赛文奥特曼扔出飞镖子类

      奥义<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 扔出飞镖 <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为什么要有子类？因为说不定作者哪天高兴又给赛文奥特曼增加了一个奥义呢。难道要修改已有的类吗？增加子类成了现有的不错的选择。但是这时候就有一个窘境，如果哪天给赛文加了三四个奥义呢？又来三四个子类，而我们的其它若干奥特曼呢。。发射激光的基本奥义应该每个都会有。都要给他们写一个子类吗</p><p>所以我们使用考虑使用桥接的模式</p><p>把奥特曼拆出来做为一部分，奥义又是一部分。 奥特曼拥有奥义这是没问题的，而奥义属于奥特曼这也是没问题的。为了奥义的复用我们把奥义也抽取出来</p><pre class="line-numbers language-csharp"><code class="language-csharp">奥义抽象类  

     奥义方法<span class="token punctuation">(</span><span class="token punctuation">)</span>



奥特曼父类

     <span class="token keyword">protected</span> 奥义抽象  成员<span class="token punctuation">;</span>

     设置奥义（奥义抽象 参数）

     <span class="token punctuation">{</span>

           <span class="token keyword">this</span><span class="token punctuation">.</span>成员<span class="token operator">=</span>参数<span class="token punctuation">;</span>

     <span class="token punctuation">}</span>

     运行奥义方法<span class="token punctuation">(</span><span class="token punctuation">)</span>

     <span class="token punctuation">{</span>

         成员<span class="token punctuation">.</span>奥义方法<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

     <span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样如果赛文需要什么奥义我们只要有一个奥义的子类并且使用赛文对象去设计奥义就可以了。而这个奥义其它的奥特曼也可以使用。这就是桥接模式带来的好处</p><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><p>将求请封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销操作</p><p>分析上面的话，重点在 请求队列的批量执行 可撤销操作。说实话看的一知半解，，打个记号以后再研究吧………</p><p>命令模式的经典角色</p><p>Command抽象类，用来声明执行操作的接口</p><p>ConcreteCommand类，将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现Exceute</p><p>Invoker类，要求该命令执行这个请求</p><p>Receiver类，知道如何实施与执行一个与请求相关的操作，任何类都可能做为一个接收者</p><p><img src="https://images2015.cnblogs.com/blog/832799/201701/832799-20170107233659612-451867439.png" referrerpolicy="no-referrer"></p><h1 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h1><p>OA系统中常常会涉及到权限，组长、主管、总监、总经理有不同的权限 。 像员工的申请，比如病假、事假等都是逐级向上。一般权限够的话就直接处理不够的话就要提交给上级处理。</p><p>手动的去指定上级肯定会造成各种各样的问题，比如需求更换、上级调整、权限重新分配等，如果仅为分支语句判断的话无疑是灾难性的。</p><p>职责链模式就是处理这种层级处理的最佳实践，请看职责链的结构图</p><pre class="line-numbers language-csharp"><code class="language-csharp">Handler 接口（抽象）类

    <span class="token keyword">private</span> Handler nextHandler<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">SetSuccessor</span><span class="token punctuation">(</span>Handler handler<span class="token punctuation">)</span>

    <span class="token punctuation">{</span>

            <span class="token keyword">this</span><span class="token punctuation">.</span>nextHandler <span class="token operator">=</span> handler<span class="token punctuation">;</span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">HandlerRequest</span><span class="token punctuation">(</span><span class="token keyword">int</span> request<span class="token punctuation">)</span><span class="token punctuation">;</span>

ConereteHandler <span class="token punctuation">:</span> Hanldler
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Handler 是职责的接口，而ConereteHandler是具体的实现，像是 组长、主管给出具体的处理，SetSuccessor 设置继任者也就是上级，当前权限不足时请示上一级的管理者去处理</p><h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>相信大多在北漂的大部分同学对租房都有着很深的印象，租房很不容易，信息渠道窄往往都要各处奔跑去找房源，费时费力。而去找中介则大大的方便了租房的过程。</p><p>中介负责联系你与房东们，你提出自己的需求，中介者去寻找合适的租房。租房过程完成后你甚至可以不用知道房东的任何信息。</p><p>设计者模式中的中介者模式也是这样的道理</p><p>首先需要有 中介者接口，可以有丰台中介者、朝阳中介者、海淀中介者等</p><p>然后是 消费者（租房/房东）抽象类</p><p>中介者需要知道所有的租房者和房东，而对于租房者和房东 他们只需要知道中介者即可</p><p>然后通过中介 ，他们就可以进行交流，完成租房过程</p><p><img src="https://images2015.cnblogs.com/blog/832799/201701/832799-20170119151429718-1357300845.png" referrerpolicy="no-referrer"></p><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>UML类图</p><p><img src="https://images2015.cnblogs.com/blog/832799/201701/832799-20170119163250875-538784095.png" referrerpolicy="no-referrer"></p><p>每个人的电脑都有输入法功能，每敲一下键盘就会打出相应的字，敲键盘的操作是重复且大量的，但是不同的是我们每次敲入的键位是不一样的，如果每敲出一个键就创建一个对象，无疑是非常耗费性能的。在这里打字是内部状态，而不同的键位是外部状态。</p><p>通过享元模式可以解决此问题，享元模式使用共享实例，适合用于只是因重复而导致使用让人无法接受的大量内存的类。通过享元工厂来创建管理对象的实例，使用 HashMap来存储对象。</p><h1 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h1><p>访问者模式可以使得作用于某对象结构中的各元素操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><p>上句话中可以用更多的话去解释，作用于某对象结构中各元素的操作，首先这个结构一定需要是稳定的，只有在一个稳定的结构下才可以去使用访问者模式。</p><p>结构图</p><p><img src="https://images2015.cnblogs.com/blog/832799/201701/832799-20170121213726078-1939675355.png" referrerpolicy="no-referrer"></p><p>visitor 为该对象结构中的ConcreteElement的每一个类声明一个visit操作</p><p>concretevisitor则是visitor的实现类，即对元素具体的操作</p><p>element 则是结构的基类，它的子类应当是在稳定的数量内</p><p>object structure 则是对象结构，可以进行添加删除及进行accept操作</p><div class="post-announce">感谢您的阅读，本文由 <a href="https://liangsw.me">liangsw</a> 版权所有。如若转载，请注明出处：liangsw（<a href="https://liangsw.me/2016/12/26/设计模式 “续”/">https://liangsw.me/2016/12/26/设计模式 “续”/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2016/12/26/Mvc中Session导致action不异步的问题/" title="Mvc中Session导致action不异步的问题"><i class="iconfont icon-prev"></i>Mvc中Session导致action不异步的问题</a></div><div class="post__prev post__prev--right"><a href="/2016/12/26/RabbitMQ 参数们的Power “续”/" title="RabbitMQ 参数们的Power “续”">RabbitMQ 参数们的Power “续”<i class="iconfont icon-next"></i></a></div></div></div></article><div id="disqus_thread"></div></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">我叫梁士伟,专注.Net最佳实践。实践毋庸置疑,我们生来就具有基因所赋予的做出各种行为的潜能,但这些潜能变成实际能力的方式取决于我们所受的训练,取决于学习</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3><ul class="block-list"><li class="block-list-item"><a class="block-list-link" href="/categories/SharpPlugs/">SharpPlugs</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/MVC5实战/">MVC5实战</a><span class="block-list-count">13</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Exceptionless/">Exceptionless</a><span class="block-list-count">3</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Entity-Framework/">Entity Framework</a><span class="block-list-count">4</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/Docker/">Docker</a><span class="block-list-count">1</span></li><li class="block-list-item"><a class="block-list-link" href="/categories/C-基础深入/">C#基础深入</a><span class="block-list-count">10</span></li></ul></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2019/05/07/Loadingrelateddata/" title="加载相关数据"><div class="item__cover"><img src="https://img2018.cnblogs.com/blog/832799/201901/832799-20190125092509730-966061697.png" alt="加载相关数据"></div><div class="item__info"><h3 class="item__title">加载相关数据</h3><span class="item__text">2019-05-07</span></div></a></li><li class="latest-post-item"><a href="/2019/04/26/Understandingdatabasequeries/" title="理解EF Core数据库查询"><div class="item__cover"><img src="https://img2018.cnblogs.com/blog/832799/201901/832799-20190125092509730-966061697.png" alt="理解EF Core数据库查询"></div><div class="item__info"><h3 class="item__title">理解EF Core数据库查询</h3><span class="item__text">2019-04-26</span></div></a></li><li class="latest-post-item"><a href="/2019/04/25/Creatingtheapplication’sDbContext/" title="创建应用程序的DbContext"><div class="item__cover"><img src="https://img2018.cnblogs.com/blog/832799/201901/832799-20190125092509730-966061697.png" alt="创建应用程序的DbContext"></div><div class="item__info"><h3 class="item__title">创建应用程序的DbContext</h3><span class="item__text">2019-04-25</span></div></a></li><li class="latest-post-item"><a href="/2019/04/24/Settingthesceneourbook-sellingsite/" title="设置一个图书销售网站的场景"><div class="item__cover"><img src="https://img2018.cnblogs.com/blog/832799/201901/832799-20190125092509730-966061697.png" alt="设置一个图书销售网站的场景"></div><div class="item__info"><h3 class="item__title">设置一个图书销售网站的场景</h3><span class="item__text">2019-04-24</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/ABP/">ABP</a></li><li class="tag-item"><a class="tag-link" href="/tags/AngularJS2/">AngularJS2</a></li><li class="tag-item"><a class="tag-link" href="/tags/AspNetCore/">AspNetCore</a></li><li class="tag-item"><a class="tag-link" href="/tags/C-基础深入/">C#基础深入</a></li><li class="tag-item"><a class="tag-link" href="/tags/CodeFirst/">CodeFirst</a></li><li class="tag-item"><a class="tag-link" href="/tags/Entity-Framework/">Entity Framework</a></li><li class="tag-item"><a class="tag-link" href="/tags/Entity-Framework-Core/">Entity Framework Core</a></li><li class="tag-item"><a class="tag-link" href="/tags/EventBus/">EventBus</a></li><li class="tag-item"><a class="tag-link" href="/tags/ExceptionLess/">ExceptionLess</a></li><li class="tag-item"><a class="tag-link" href="/tags/MVC/">MVC</a></li><li class="tag-item"><a class="tag-link" href="/tags/Newtonsoft-Json/">Newtonsoft.Json</a></li><li class="tag-item"><a class="tag-link" href="/tags/RabbitMQ/">RabbitMQ</a></li><li class="tag-item"><a class="tag-link" href="/tags/SignalR/">SignalR</a></li><li class="tag-item"><a class="tag-link" href="/tags/TypeScript/">TypeScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/aspnetcore/">aspnetcore</a></li><li class="tag-item"><a class="tag-link" href="/tags/docker/">docker</a></li><li class="tag-item"><a class="tag-link" href="/tags/eShopOnContainers/">eShopOnContainers</a></li><li class="tag-item"><a class="tag-link" href="/tags/geetest/">geetest</a></li><li class="tag-item"><a class="tag-link" href="/tags/logdashboard/">logdashboard</a></li><li class="tag-item"><a class="tag-link" href="/tags/wsl/">wsl</a></li><li class="tag-item"><a class="tag-link" href="/tags/小程序/">小程序</a></li><li class="tag-item"><a class="tag-link" href="/tags/异常日志/">异常日志</a></li><li class="tag-item"><a class="tag-link" href="/tags/异步编程/">异步编程</a></li><li class="tag-item"><a class="tag-link" href="/tags/极验/">极验</a></li><li class="tag-item"><a class="tag-link" href="/tags/翻译/">翻译</a></li><li class="tag-item"><a class="tag-link" href="/tags/设计模式/">设计模式</a></li><li class="tag-item"><a class="tag-link" href="/tags/项目经验/">项目经验</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">梁士伟</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>BeiJing, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>liangshiw@outlook.com</span></li></ul></div></div><div class="footer-top__item footer__image"><img src="https://img2018.cnblogs.com/blog/832799/201901/832799-20190116134451377-762296667.jpg" referrerpolicy="no-referrer" alt="logo" title="liangsw"></div><div class="footer-top__item"><h3 class="item__title">友情链接</h3><div class="item__content"><ul class="footer-top__list"><li class="list-item"><a href="https://maliming.github.io/" title="malimingBlog" target="_blank">malimingBlog</a></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright"></p><ul class="footer__social-network clearfix"><li class="social-network__item"><a href="https://github.com/liangshiw" target="_blank" title="github"><i class="iconfont icon-github"></i></a></li><li class="social-network__item"><a href="https://www.zhihu.com/people/bian-cheng-meng/activities" target="_blank" title="zhihu"><i class="iconfont icon-zhihu"></i></a></li><li class="social-network__item"><a href="https://www.douban.com/people/169679237/" target="_blank" title="douban"><i class="iconfont icon-douban"></i></a></li><li class="social-network__item"><a href="https://www.linkedin.com/in/%E5%A3%AB%E4%BC%9F-%E6%A2%81-338999145/" target="_blank" title="linkedin"><i class="iconfont icon-in"></i></a></li><li class="social-network__item"><a href="liangshiw@outlook.com" target="_blank" title="email"><i class="iconfont icon-email"></i></a></li></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script>var disqus_shortname="http-liangsw-me",disqus_config=function(){this.page.url="https://liangsw.me/2016/12/26/设计模式 “续”/",this.page.identifier="/2016/12/26/设计模式 “续”/",this.page.title="设计模式 “续”"};!function(){var t=document,e=t.createElement("script");e.src="https://"+disqus_shortname+".disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>